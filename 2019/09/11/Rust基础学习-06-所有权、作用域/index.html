<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="日常记录"><title>Rust基础学习-06-所有权、作用域 | F社</title><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><header class="wrapper header"><div class="container blog-title"><a class="title" id="logo" href="/.">F社</a><span class="subtitle">上你娘的班</span><label id="toggle-menu" for="menu" onclick><i class="fa fa-bars"></i></label></div><input id="menu" type="checkbox"><div class="container nav-items"><a class="sidebar-nav-item active" href="/">主页</a><a class="sidebar-nav-item" href="/archives">分类归档</a><a class="sidebar-nav-item" href="/about">关于</a><a class="sidebar-nav-item" href="/links">收集</a></div></header><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><!--each nav, name in theme.menu//+a_with_current(nav, __(name))--></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/Rust/">Rust</a></div><div class="post-time">2019-09-11</div></div></div><div class="container post-header"><h1>Rust基础学习-06-所有权、作用域</h1></div><div class="container post-content"><p>本篇博客我们来解释几个名词，<strong><code>栈</code></strong>、<strong><code>堆</code></strong>、<strong><code>作用域</code></strong>、<strong><code>所有权</code></strong>、<strong><code>所有权移动</code></strong></p>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>栈是在代码运行时，可供使用的一块内存。它的存取数据方式是<code>先进后出</code>，或者说<code>后进先出</code>。想象有一个箱子，你往里放本子，最先放入的本子，是在箱子底下，当你要使用本子时，总是从顶上取一个使用，也就是取最后放入的一个本子。<br><strong>因为这种存取数据时总是在栈顶操作，而不需要去内存中寻找一个位置，所以栈的操作是时分迅速的。</strong><br>还有一个点是，存在栈里的数据，都是以知的固定大小。这一点的意思是，<em>例如要让用户输入一个名字，因为不知道用户会输入多少字符，所以这个数据就无法放在栈中，因为无法事先知道明确的大小。</em></p>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>在编译时大小未知或大小可能变化的数据，要改为存储在堆上。堆是缺乏组织的：当向堆放入数据时，你要请求一定大小的空间。操作系统在堆的某处找到一块足够大的空位，把它标记为已使用，并返回一个表示该位置地址的 <code>指针（pointer）</code>。这个过程称作 在堆上分配内存<code>（allocating on the heap）</code>，有时简称为 <code>分配（allocating）</code>。</p>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>作用域可以理解为一个东西在程序中的有效范围。对于Rust来说，当一个变量出了作用域后，对应的内存就会自动被释放掉，变量变为无效状态。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;                      <span class="comment">// s 在这里无效, 它尚未声明</span></span><br><span class="line">    <span class="keyword">let</span> s = <span class="string">"hello"</span>;   <span class="comment">// 从此处起，s 是有效的</span></span><br><span class="line">    <span class="comment">// 使用 s</span></span><br><span class="line">&#125;                      <span class="comment">// 此作用域已结束，s 不再有效</span></span><br></pre></td></tr></table></figure></p>
<h2 id="字符串类型-String"><a href="#字符串类型-String" class="headerlink" title="字符串类型 String"></a>字符串类型 String</h2><p>之前在数据类型一节，没有讲到 String，是因为牵扯到堆栈的问题，所以放在这里讲。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="comment">// 像这种直接硬编码在代码里的字符串，是放在栈上的，并且不可改变</span></span><br><span class="line">    <span class="keyword">let</span> name = <span class="string">"Jack"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用String::from创建的，是在堆上分配内存，并且是可以改变的</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> my_name = <span class="built_in">String</span>::from(<span class="string">"Jack"</span>);</span><br><span class="line">    my_name.push_str(<span class="string">", My name is Jack"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出 Jack, My name is Jack</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, my_name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>当调用 <code>String::from</code> 时，它的实现 (implementation) 请求其所需的内存。这在编程语言中是非常通用的。</p>
</blockquote>
<h2 id="所有权"><a href="#所有权" class="headerlink" title="所有权"></a>所有权</h2><ol>
<li>Rust 中每一个值都有一个被称为<strong><code>所有者</code></strong>的变量</li>
<li>值，有且只有一个所有者</li>
<li>当所有者（变量）离开作用域时，这个值被丢弃，内存被释放</li>
</ol>
<h2 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h2><p>先看下面一段代码<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">let</span> y = x;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"x: &#123;&#125;, y:&#123;&#125;"</span>, x, y);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> name1 = <span class="string">"Fred"</span>;</span><br><span class="line">    <span class="keyword">let</span> name2 = name1;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"name1: &#123;&#125;, name2: &#123;&#125;"</span>, name1, name2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>很正常，最后输出了 <code>x: 10, y:10</code> 和 <code>name1: Fred, name2: Fred</code></p>
<p>再看下面这段代码<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> name1 = <span class="built_in">String</span>::from(<span class="string">"Fred"</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"name1: &#123;&#125;"</span>, name1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> name2 = name1;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"name2: &#123;&#125;"</span>, name2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编译出错，这句会出错</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"name1 again: &#123;&#125;"</span>, name1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>为什么加了最后一句会编译出错呢，这里涉及到一个概念，<code>移动</code>。首先 name1 指向的值是分配在堆上的。当将 name1 赋值 给 name2后，在有一些编程语言，两个变量会指向同一块堆内存区域，但是对于Rust来说，不是这样的，Rust在这里会直接让 name1 <code>失效</code>，避免两个指针指向同一块堆内存。因为 Rust 会自动释放内存，这样可以避免当两个变量超出作用域时，导致重复的内存释放问题。将 name1 赋值给 name2，这个操作叫做<code>移动</code>，name1移动到了name2，移动后，name1自动失效，所以最后一句访问 name1 会编译出错。</p>
<p>更详细的内容 <a href="https://kaisery.github.io/trpl-zh-cn/ch04-01-what-is-ownership.html" target="_blank" rel="noopener">官方文档</a></p>
<blockquote>
<p>这里要记住，对于那些固定大小的数据类型，<code>i32</code>, <code>f32</code>, <code>bool</code>，<code>char</code> 等不会存在<code>移动</code>的问题。但是对于存储在<code>堆</code>上的数据，不管是String还是后面自定义的数据类型，这样的操作都会触发<code>移动</code></p>
</blockquote>
<h4 id="有没有办法将指上堆内存的变量赋值给另一个变量不触发移动呢？有！方法就是克隆，看下面的代码。"><a href="#有没有办法将指上堆内存的变量赋值给另一个变量不触发移动呢？有！方法就是克隆，看下面的代码。" class="headerlink" title="有没有办法将指上堆内存的变量赋值给另一个变量不触发移动呢？有！方法就是克隆，看下面的代码。"></a>有没有办法将指上堆内存的变量赋值给另一个变量不触发<code>移动</code>呢？有！方法就是克隆，看下面的代码。</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> name1 = <span class="built_in">String</span>::from(<span class="string">"Fred"</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"name1: &#123;&#125;"</span>, name1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> name2 = name1.clone();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"name2: &#123;&#125;"</span>, name2);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"name1 again: &#123;&#125;"</span>, name1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和之前的代码只有第5行变了，当调用了 <code>clone()</code>函数后，会导致 name1 指向的堆上的内存复制一份。所以这里就没有<code>移动</code>。String内部实现了 <code>clone()</code>，当我们自定义数据结构时，如果要有克隆功能，需要自己实现 <code>clone()</code>方法。这个后面会讲到。</p>
<h2 id="移动与函数"><a href="#移动与函数" class="headerlink" title="移动与函数"></a>移动与函数</h2><p>说完了<code>移动</code>，就需要说一下移动和函数相关的东西。如果将一个值作为参数，去调用一个函数，如果这个值是在栈上，那么不会发生什么，但是如果这个值是分配在堆上，那么它会移动到函数内部。</p>
<p>看下面的代码（注意看代码的注释）<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> name1 = <span class="built_in">String</span>::from(<span class="string">"Fred"</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"name1: &#123;&#125;"</span>, name1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// name1 的值移动了函数里</span></span><br><span class="line">    takes_ownership((name1));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// name1 已经无效，这里再使用就会编译出错</span></span><br><span class="line">    <span class="comment">// println!("name1 again: &#123;&#125;", name1);</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">takes_ownership</span></span>(<span class="built_in">str</span>: <span class="built_in">String</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"i have ownership: &#123;&#125;"</span>, <span class="built_in">str</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面的代码，函数在结束时将 <code>所有权</code> 返回<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> name1 = <span class="built_in">String</span>::from(<span class="string">"Fred"</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"name1: &#123;&#125;"</span>, name1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为name1不是mut的，所以这里的name1相当于创建了一个</span></span><br><span class="line">    <span class="comment">// 新的变量name1, 本质上并不是之前的</span></span><br><span class="line">    <span class="keyword">let</span> name1 = takes_and_gives_back(name1);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"name1 again: &#123;&#125;"</span>, name1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">takes_and_gives_back</span></span>(<span class="built_in">str</span>: <span class="built_in">String</span>) -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"i have ownership: &#123;&#125;"</span>, <span class="built_in">str</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这里将值返回，所有权移出函数</span></span><br><span class="line">    <span class="built_in">str</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="使用函数时每次都要转移所有权很繁琐，所下一节将介绍引用，不用每次将所有权转来转去"><a href="#使用函数时每次都要转移所有权很繁琐，所下一节将介绍引用，不用每次将所有权转来转去" class="headerlink" title="使用函数时每次都要转移所有权很繁琐，所下一节将介绍引用，不用每次将所有权转来转去"></a>使用函数时每次都要转移所有权很繁琐，所下一节将介绍<code>引用</code>，不用每次将所有权转来转去</h4></div></div><script type="text/x-mathjax-config">
   MathJax.Hub.Config({"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"], linebreaks: { automatic:true }, EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) },
        tex2jax: { inlineMath: [ ["$", "$"], ["\\(","\\)"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno",skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']},
        TeX: {  noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } }, Macros: { href: "{}" } },
        messageStyle: "none"
    }); 
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<script type="text/javascript" src="https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><div class="post-main post-comment"><div id="disqus_thread"></div><script type="text/javascript">
var disqus_shortname = 'sexy-game-boy';
var disqus_identifier = '2019/09/11/Rust基础学习-06-所有权、作用域/';
var disqus_title = 'Rust基础学习-06-所有权、作用域';
var disqus_url = 'https://solleter.me/2019/09/11/Rust基础学习-06-所有权、作用域/';
(function() {
   var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
   dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
   (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">Blog comments powered by <span class="logo-disqus">Disqus</span></a></div></article><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=
function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;
e=o.createElement(i);r=o.getElementsByTagName(i)[0];
e.src='//www.google-analytics.com/analytics.js';
r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));
ga('create','UA-140200191-1');ga('send','pageview');</script></body></html>