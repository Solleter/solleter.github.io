<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>F社</title>
  
  <subtitle>上你娘的班</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://solleter.me/"/>
  <updated>2019-10-27T09:03:54.797Z</updated>
  <id>https://solleter.me/</id>
  
  <author>
    <name>F君</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>图形学笔记-01-导论</title>
    <link href="https://solleter.me/2019/10/27/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0-01-%E5%AF%BC%E8%AE%BA/"/>
    <id>https://solleter.me/2019/10/27/图形学笔记-01-导论/</id>
    <published>2019-10-27T09:01:29.000Z</published>
    <updated>2019-10-27T09:03:54.797Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Fundamentals of Computer Graphics, 4th Edition 这本书从算法和数学方面，介绍计算机图形学。而计算机图形学在很多领域都有相关应用，例如游戏开发，大量地使用计算机图形学，用于渲染各种漂亮的效果。</p><p>计算机硬件发展很快，而图形学涉及到各种不同硬件平台的API。但是这本书，将尽量不依赖于特定的API，从基本原理上，去介绍图形学相关的知识。</p></blockquote><h2 id="1-主要应用"><a href="#1-主要应用" class="headerlink" title="1. 主要应用"></a>1. 主要应用</h2><ul><li>游戏</li><li>动漫</li><li>视觉特效</li><li>动画电影</li><li>CAD/CAM</li><li>模拟仿真</li><li>医学影像</li><li>信息可视化</li></ul><h2 id="2-图形API"><a href="#2-图形API" class="headerlink" title="2. 图形API"></a>2. 图形API</h2><ul><li>Toolkits</li><li>Direct3D/OpenGL</li></ul><h2 id="3-图形流水线"><a href="#3-图形流水线" class="headerlink" title="3. 图形流水线"></a>3. 图形流水线</h2><ul><li>现在的计算机，拥有很强大的3D图形流水线。这个子系统用于高效的绘制3D图元。这些子系统对于处理3D三角形和共享顶点进行了深度优化。在这个流水线中最基本的操作是将3D顶点的位置，转换成2D屏幕坐标，然后绘制在屏幕上。</li><li>对于绘制三角形的顺序，现在几乎总是使用Z缓冲技术来解决。</li><li>能图形流水线中的几可操作，可以以四维坐标空间来实现。而四维坐标空间，使用4x4的矩阵来描述。</li><li>LOD可以用于优化效率，当模型距离较远时，可以通过减少三角形来提高渲染效率，而较近时，则使用高精度的模型。</li></ul><h2 id="4-数值问题"><a href="#4-数值问题" class="headerlink" title="4. 数值问题"></a>4. 数值问题</h2><p>IEEE Standards Association, 1985</p><p>三个重要的值</p><ul><li>Infinity (∞)</li><li>Minus infinity (−∞)</li><li>Not a number (NaN)</li></ul><h2 id="5-效率"><a href="#5-效率" class="headerlink" title="5. 效率"></a>5. 效率</h2><p>没有什么魔法规则能让代码更有效率。涉及到效率问题时，要仔细去权衡。</p><ul><li>注意内存访问模式</li><li>写清晰简单的代码</li><li>使用Optimized模式编译代码</li><li>使用分析工具找到瓶颈</li><li>检查数据结构</li><li>!!! 对于现代CPU来说，使用<code>整型</code>代替<code>浮点型</code>已经不能带来什么效率提升。</li></ul><h2 id="6-基本的数据结构"><a href="#6-基本的数据结构" class="headerlink" title="6. 基本的数据结构"></a>6. 基本的数据结构</h2><ul><li><p>Vector2</p><p>通常用于存储 x, y 值</p></li><li><p>Vector3</p><p>通常用于存储 x, y, z 值</p></li><li><p>Hvector</p><p>用于存储 x, y, z, w 值</p></li><li><p>Transform</p><p>用于存储 4x4 矩阵，用于表示转换</p></li><li><p>RGB</p><p>用于存储 红, 绿, 蓝 三色的值</p></li><li><p>Image</p><p>RGB颜色值的二维数组，通常用于存储输出的图像</p></li></ul><h2 id="7-调试图形程序"><a href="#7-调试图形程序" class="headerlink" title="7. 调试图形程序"></a>7. 调试图形程序</h2><p>没有什么具体的标准</p><ul><li>输出看看</li><li>使用断点</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Fundamentals of Computer Graphics, 4th Edition 这本书从算法和数学方面，介绍计算机图形学。而计算机图形学在很多领域都有相关应用，例如游戏开发，大量地使用计算机图形学，用于渲染各种漂亮的效果。&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="Fundamentals of Computer Graphics" scheme="https://solleter.me/categories/Fundamentals-of-Computer-Graphics/"/>
    
    
      <category term="图形学" scheme="https://solleter.me/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>只需要几步即可拥有自己的VPS</title>
    <link href="https://solleter.me/2019/10/11/%E5%8F%AA%E9%9C%80%E8%A6%81%E5%87%A0%E6%AD%A5%E5%8D%B3%E5%8F%AF%E6%8B%A5%E6%9C%89%E8%87%AA%E5%B7%B1%E7%9A%84VPS/"/>
    <id>https://solleter.me/2019/10/11/只需要几步即可拥有自己的VPS/</id>
    <published>2019-10-11T10:32:43.000Z</published>
    <updated>2019-10-27T09:00:31.662Z</updated>
    
    <content type="html"><![CDATA[<p>这篇博客将一步一步教大家学习VPS的购买和配置教程，只需要简单几步，就可以拥有自己的VPS，然后愉快玩耍。可以自己搭一个科学上网代理服务器啦，托管自己的博客啦，等等。</p><p>VPS服务商有很多种，这们我们选择相对比较稳定的 Vultr。</p><p>Vultr的收费模式是按时间累计收费的，首先需要往自己帐号里充值。当创建一个实例后，则计费开始。例如选择的是5美元每月的服务器，也就是大概每小时0.007美元，如果你只用了10个小时就把VPS实例删了，那就只会消费掉0.07美元。</p><h2 id="1-首先点击这里，打开-Vultr-官网"><a href="#1-首先点击这里，打开-Vultr-官网" class="headerlink" title="1. 首先点击这里，打开 Vultr 官网"></a>1. <a href="https://www.vultr.com/?ref=8288434" target="_blank" rel="noopener">首先点击这里，打开 Vultr 官网</a></h2><p>然后点击右上角的 <strong>Sign up</strong> 进入注册页面，然后输入邮箱和密码以及验证码，注册一个 Vultr 账户</p><p><img src="https://i.loli.net/2019/10/11/b4DREmgiwqcKlXz.png" alt="1.png"></p><h2 id="2-充值"><a href="#2-充值" class="headerlink" title="2. 充值"></a>2. 充值</h2><p>注册完后，会自动登录，并跳转到账单页面，因为现在账户里还没有金额，所以需要先充一点。刚开始，可以先充最小金额，也就是10美元，一般都会有金额赠送，现在有<strong>充10美元</strong>，会额外<strong>赠送50美元</strong>的活动，但是这50美元有试用期限。这个活动在写本文的时候还有，不知道什么时候结束。</p><p>可以使用信用卡，支付宝，微信等方式支付，还是很方便的。</p><p><img src="https://i.loli.net/2019/10/11/F4KUepQb6HhLs9E.png" alt="2.png"></p><h2 id="3-创建-VPS-实例"><a href="#3-创建-VPS-实例" class="headerlink" title="3. 创建 VPS 实例"></a>3. 创建 VPS 实例</h2><ol><li>第一张图，点击左边的<strong>Products</strong>，然后选择右边的 <strong>Cloud Compute</strong></li><li>第二张图，选择VPS所属的机房，经过我的测试，感觉 <strong>Los Angeles</strong>(洛杉矶) 的相对来说比较稳定，所以这里就用洛杉矶机房的机器。</li><li>第三张图，选择 <strong>操作系统</strong> 和  <strong>付费方案</strong>，操作系统这里试用 <strong>Ubuntu</strong>，版本使用 <strong>18.04</strong> 和 <strong>19.04</strong> 都可以。然后选择下面 <strong>$5/mo</strong> 的方案，然后点击 <strong>Deploy Now</strong> 就会开始创建VPS实例</li><li>等待 <strong>Instaling</strong> 状态变为 <strong>Running</strong> 状态，则表示VPS已经创建好，正在运行中。</li></ol><p><img src="https://i.loli.net/2019/10/11/vQkus8GhSIPOjax.png" alt="3.png"></p><p><img src="https://i.loli.net/2019/10/11/f3AYm7NK6FHjp4g.png" alt="4.png"></p><p><img src="https://i.loli.net/2019/10/11/yMrb2mNugcazYTD.png" alt="5.png"></p><p><img src="https://i.loli.net/2019/10/11/gfbaedNTDnzsWQi.png" alt="6.png"></p><p><img src="https://i.loli.net/2019/10/11/5UqjNEIA3us7vpn.png" alt="7.png"></p><h2 id="4-登录-VPS"><a href="#4-登录-VPS" class="headerlink" title="4. 登录 VPS"></a>4. 登录 VPS</h2><p>当 VPS实例变为 <strong>Running</strong> 状态后，点击左边的 <strong>Cloud Intance</strong>，即可进入当前实例的信息页面，如下图。接下来使用 <strong>SSH</strong> 登录VPS</p><ol><li>打开命令行，如果是Window，可以使用CMD，如果是Linux或者Mac，则使用对应的终端即可。</li><li>复制IP，然后在命令行中输入命令 <code>ssh root@45.77.125.227</code>，这里的IP换成你的VPS实例IP。然后回车，因为是第一次登录，所以会询问是否确认连接，这里输入 <code>yes</code>，然后回车。</li><li>接下来会要求输入密码，在当前实例信息页面，<strong>Password</strong> 后面就是密码，默认是隐藏的，可以点击那个 “眼睛” 的图标显示出来，也可以点击后面那个图标复制密码。</li><li>复制密码后，在命令行中粘贴。如果你是在CMD中，只要聚焦在CMD窗口，按一下右键就可以粘贴上。注意，命令行中密码是不显示的。粘贴上后按回车，即可成功登录。</li></ol><p><img src="https://i.loli.net/2019/10/11/qEITmdhKzAVUMwy.png" alt="8.png"></p><p><img src="https://i.loli.net/2019/10/11/zcsTPerik7KGujt.png" alt="9.png"></p><h2 id="5-修改VPS密码"><a href="#5-修改VPS密码" class="headerlink" title="5. 修改VPS密码"></a>5. 修改VPS密码</h2><p>Vultr 的VPS实例默认生成的密码是随机的，不好记，所以我们在登录后，先去改个密码，改成自己容易记忆的密码。</p><p>使用命令 <code>passwd root</code> 命令，回车，然后输入密码，再次输入密码，当看到 <strong>passwd: password updated successfully</strong> 的字样，则表示密码修改成功。下次登录时，就可以使用自己的密码登录了。</p><p><img src="https://i.loli.net/2019/10/11/V9ml8se2DFaOREf.png" alt="10.png"></p><p> 好了，VPS的购买及配置教程就结束了，只要跟着一步一步来，还是很简单的。如果有什么问题，欢迎在下面留言。</p><p>VPS搭建好了，接下来就是使用VPS做一些事情，登录搭建个科学上网的梯子之类的，这将在后面的博客中介绍。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这篇博客将一步一步教大家学习VPS的购买和配置教程，只需要简单几步，就可以拥有自己的VPS，然后愉快玩耍。可以自己搭一个科学上网代理服务器啦，托管自己的博客啦，等等。&lt;/p&gt;
&lt;p&gt;VPS服务商有很多种，这们我们选择相对比较稳定的 Vultr。&lt;/p&gt;
&lt;p&gt;Vultr的收
      
    
    </summary>
    
    
      <category term="Ubuntu" scheme="https://solleter.me/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>在Ubuntu上开启Swap</title>
    <link href="https://solleter.me/2019/10/11/%E5%9C%A8Ubuntu%E4%B8%8A%E5%BC%80%E5%90%AFSwap/"/>
    <id>https://solleter.me/2019/10/11/在Ubuntu上开启Swap/</id>
    <published>2019-10-11T02:09:28.000Z</published>
    <updated>2019-10-27T09:00:31.663Z</updated>
    
    <content type="html"><![CDATA[<p>在内存不够大时，需要开启Swap，使用一部分硬盘，作为虚拟内存，解决内存容量不足的情况。这篇博客是以 Ubuntu 基础来操作的，其他 Linux 系统基本类似。很简单，跟着下面的步骤，一步一步来操作即可。</p><blockquote><p>注意：下面命令的操作，都是在终端中进行的</p></blockquote><h2 id="1-确定当前没有开启-Swap"><a href="#1-确定当前没有开启-Swap" class="headerlink" title="1. 确定当前没有开启 Swap"></a>1. 确定当前没有开启 Swap</h2><p>在终端使用命令 <code>free -m</code> 查看输出结果</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">total              used       free     shared    buffers     cached</span><br><span class="line">Mem:              <span class="number"> 1840 </span>     <span class="number"> 1614 </span>   <span class="number"> 226 </span>     <span class="number"> 15 </span>        <span class="number"> 36 </span>      1340</span><br><span class="line">-/+ buffers/cache:           <span class="number"> 238 </span>     1602</span><br><span class="line">Swap:             <span class="number"> 0 </span>        <span class="number"> 0 </span>       0</span><br></pre></td></tr></table></figure><p>可以看到最后一行是0 0 0，则表示当前没有开启。</p><h2 id="2-创建-Swap-文件"><a href="#2-创建-Swap-文件" class="headerlink" title="2. 创建 Swap 文件"></a>2. 创建 Swap 文件</h2><p>使用下面命令创建交换文件。因为要分配硬盘空间，所以有可能比较慢，等待一会</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd if=/dev/zero of=/swapfile count=2048 bs=1M</span><br></pre></td></tr></table></figure><p><strong>count=2048</strong> 表示创建 2G 的虚拟内存，因为这里用到的单位是 <code>M</code>，如果要创建 6G 虚拟内存，则把2048 改成 6144 即可，因为 1024 * 6 = 6144。</p><p>可以使用 <code>ls / | grep swapfile</code> 命令查看一下，确保交换文件存在，创建成功。</p><h2 id="3-激活-Swap-文件"><a href="#3-激活-Swap-文件" class="headerlink" title="3. 激活 Swap 文件"></a>3. 激活 Swap 文件</h2><p>依次执行下面的命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 600 /swapfile</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkswap /swapfile</span><br></pre></td></tr></table></figure><p>依次运行上面两个命令后，如果成功，将会看到类似下面的输出</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Setting up swapspace version <span class="number">1</span>, size = <span class="number">2097148</span> KiB</span><br><span class="line">no label, UUID=ff3fc469<span class="number">-9</span>c4b<span class="number">-4913</span>-b653-ec53d6460d0e</span><br></pre></td></tr></table></figure><h2 id="4-开启-Swap"><a href="#4-开启-Swap" class="headerlink" title="4. 开启 Swap"></a>4. 开启 Swap</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swapon /swapfile</span><br></pre></td></tr></table></figure><p>到这里，Swap 已经开启成功。我们再次使用 <code>free -m</code> 命令查看一下，你将看到类似下面的输出。</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">total       used       free     shared    buffers     cached</span><br><span class="line">Mem:         <span class="number"> 1840 </span>     <span class="number"> 1754 </span>       <span class="number"> 86 </span>       <span class="number"> 16 </span>       <span class="number"> 23 </span>      1519</span><br><span class="line">-/+ buffers/cache:       <span class="number"> 210 </span>      1630</span><br><span class="line">Swap:        <span class="number"> 2047 </span>        <span class="number"> 0 </span>      2047</span><br></pre></td></tr></table></figure><p>最后一行 Swap 将不再是0 0 0，而是我们上面设置的大小</p><h2 id="5-设置系统启动时自动开启-Swap"><a href="#5-设置系统启动时自动开启-Swap" class="headerlink" title="5. 设置系统启动时自动开启 Swap"></a>5. 设置系统启动时自动开启 Swap</h2><p>使用编辑器编辑 <strong>/etc/fstab</strong> 文件，添加 Swap 自动开启的配置，这里使用 Vim进行编辑，也可以使用其他文本编辑工具，例如 nano</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/fstab</span><br></pre></td></tr></table></figure><p>在 fstab 文件最后一行添加下面的内容</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/swapfile none swap sw <span class="number">0</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p>然后保存，退出。</p><h4 id="好了，现在-Swap-已经配置完，并且可以在系统启动时自动开启。"><a href="#好了，现在-Swap-已经配置完，并且可以在系统启动时自动开启。" class="headerlink" title="好了，现在 Swap 已经配置完，并且可以在系统启动时自动开启。"></a>好了，现在 Swap 已经配置完，并且可以在系统启动时自动开启。</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在内存不够大时，需要开启Swap，使用一部分硬盘，作为虚拟内存，解决内存容量不足的情况。这篇博客是以 Ubuntu 基础来操作的，其他 Linux 系统基本类似。很简单，跟着下面的步骤，一步一步来操作即可。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：下面命令的操作，都是
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://solleter.me/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>游戏开发中的配置文件</title>
    <link href="https://solleter.me/2019/10/08/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
    <id>https://solleter.me/2019/10/08/游戏开发中的配置文件/</id>
    <published>2019-10-08T07:19:37.000Z</published>
    <updated>2019-10-10T14:55:45.858Z</updated>
    
    <content type="html"><![CDATA[<p>在游戏开发过程中，有一些简单的配置，不需要走表，使用一个文本文件去配置，更方便。</p><p><strong>1. 配置文件格式如下，[Config.txt]</strong>，文件名自己定义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">GameFrame = 60</span><br><span class="line"></span><br><span class="line">[Login]</span><br><span class="line">LoginChannel = 1</span><br><span class="line">TestUserName = JackLong</span><br><span class="line">TestPassword = HahaFuckyou</span><br><span class="line"></span><br><span class="line">[Net]</span><br><span class="line">Timeout = 3.5</span><br><span class="line"></span><br><span class="line">[Debug]</span><br><span class="line">DebugMode = true</span><br><span class="line">DebugMode2 = false</span><br></pre></td></tr></table></figure><p><strong>“[ ]”</strong> 中的部分，为模块名称，像 <strong>GameFrame</strong> 这样没有在某个模块下的配置，为全局配置</p><p><strong>2. 如何使用</strong></p><blockquote><p><code>注意：在游戏开始时，首先要读取配置文件，路径自己定义</code></p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">string</span> path = <span class="string">@"D:/Config.txt"</span>;</span><br><span class="line">SimpleConfig.Load(path);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> gameFrame = SimpleConfig.GetIntValue(<span class="string">"GameFrame"</span>);</span><br><span class="line"><span class="keyword">int</span> loginChannel = SimpleConfig.GetIntValue(<span class="string">"Login"</span>, <span class="string">"LoginChannel"</span>);</span><br><span class="line"><span class="keyword">string</span> testUserName = SimpleConfig.GetStringValue(<span class="string">"Login"</span>, <span class="string">"TestUserName"</span>);</span><br><span class="line"><span class="keyword">string</span> testPassword = SimpleConfig.GetStringValue(<span class="string">"Login"</span>, <span class="string">"TestPassword"</span>);</span><br><span class="line"><span class="keyword">float</span> timeout = SimpleConfig.GetFloatValue(<span class="string">"Net"</span>, <span class="string">"Timeout"</span>);</span><br><span class="line"><span class="keyword">bool</span> dm = SimpleConfig.GetBoolValue(<span class="string">"Debug"</span>, <span class="string">"DebugMode"</span>);</span><br><span class="line"><span class="keyword">bool</span> dm2 = SimpleConfig.GetBoolValue(<span class="string">"Debug"</span>, <span class="string">"DebugMode2"</span>);</span><br><span class="line"></span><br><span class="line">Debug.LogFormat(<span class="string">"GameFrame: &#123;0&#125;"</span>, gameFrame);</span><br><span class="line">Debug.LogFormat(<span class="string">"LoginChannel: &#123;0&#125;"</span>, loginChannel);</span><br><span class="line">Debug.LogFormat(<span class="string">"testUserName: &#123;0&#125;"</span>, testUserName);</span><br><span class="line">Debug.LogFormat(<span class="string">"testPassword: &#123;0&#125;"</span>, testPassword);</span><br><span class="line">Debug.LogFormat(<span class="string">"timeout: &#123;0&#125;"</span>, timeout);</span><br><span class="line">Debug.LogFormat(<span class="string">"dm: &#123;0&#125;,  dm2: &#123;1&#125;"</span>, dm, dm2);</span><br></pre></td></tr></table></figure><p><strong>3. 源代码</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">SimpleConfig</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Dictionary&lt;<span class="keyword">string</span>, Dictionary&lt;<span class="keyword">string</span>, <span class="keyword">string</span>&gt;&gt; dataDict = <span class="keyword">new</span> Dictionary&lt;<span class="keyword">string</span>, Dictionary&lt;<span class="keyword">string</span>, <span class="keyword">string</span>&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Load</span>(<span class="params"><span class="keyword">string</span> configFilePath</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">var</span> enumer = dataDict.GetEnumerator();</span><br><span class="line">        <span class="keyword">while</span> (enumer.MoveNext())</span><br><span class="line">        &#123;</span><br><span class="line">            enumer.Current.Value.Clear();</span><br><span class="line">        &#125;</span><br><span class="line">        dataDict.Clear();</span><br><span class="line"></span><br><span class="line">        System.IO.StreamReader sr = <span class="keyword">new</span> System.IO.StreamReader(configFilePath);</span><br><span class="line">        <span class="keyword">string</span> line;</span><br><span class="line">        <span class="keyword">string</span> currSection = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">char</span>[] splitor = <span class="keyword">new</span> <span class="keyword">char</span>[] &#123; <span class="string">'='</span> &#125;;</span><br><span class="line">        <span class="keyword">while</span>((line = sr.ReadLine()) != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            line = line.Trim();</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">string</span>.IsNullOrEmpty(line))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(line.StartsWith(<span class="string">"["</span>) &amp;&amp; line.EndsWith(<span class="string">"]"</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                currSection = line.Substring(<span class="number">1</span>, line.Length - <span class="number">2</span>);</span><br><span class="line">                <span class="keyword">if</span> (!dataDict.ContainsKey(currSection))</span><br><span class="line">                &#123;</span><br><span class="line">                    dataDict.Add(currSection, <span class="keyword">new</span> Dictionary&lt;<span class="keyword">string</span>, <span class="keyword">string</span>&gt;());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">string</span>[] keyAndValue = line.Split(splitor, <span class="number">2</span>);</span><br><span class="line">                <span class="keyword">if</span>(keyAndValue == <span class="literal">null</span> || keyAndValue.Length &lt; <span class="number">2</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(currSection == <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    currSection = <span class="string">"Global"</span>;</span><br><span class="line">                    <span class="keyword">if</span> (!dataDict.ContainsKey(currSection))</span><br><span class="line">                    &#123;</span><br><span class="line">                        dataDict.Add(currSection, <span class="keyword">new</span> Dictionary&lt;<span class="keyword">string</span>, <span class="keyword">string</span>&gt;());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">string</span> key = keyAndValue[<span class="number">0</span>].Trim();</span><br><span class="line">                <span class="keyword">string</span> <span class="keyword">value</span> = keyAndValue[<span class="number">1</span>].Trim();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (dataDict[currSection].ContainsKey(key))</span><br><span class="line">                &#123;</span><br><span class="line">                    Debug.LogErrorFormat(<span class="string">"在 &#123;0&#125; 部分已经包含名为 &#123;1&#125; 的变量！"</span>, currSection, key);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                dataDict[currSection].Add(key, <span class="keyword">value</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">GetIntValue</span>(<span class="params"><span class="keyword">string</span> variable</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> GetIntValue(<span class="string">"Global"</span>, variable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">GetIntValue</span>(<span class="params"><span class="keyword">string</span> section, <span class="keyword">string</span> variable</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span> (dataDict.ContainsKey(section) &amp;&amp; dataDict[section].ContainsKey(variable))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">string</span> rawValue = dataDict[section][variable];</span><br><span class="line">            <span class="keyword">int</span> <span class="keyword">value</span> = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">int</span>.TryParse(rawValue, <span class="keyword">out</span> <span class="keyword">value</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">value</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Debug.LogErrorFormat(<span class="string">"解析 &#123;0&#125; 部分的 &#123;1&#125; int 值出错"</span>, section, variable);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">float</span> <span class="title">GetFloatValue</span>(<span class="params"><span class="keyword">string</span> variable</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> GetFloatValue(<span class="string">"Global"</span>, variable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">float</span> <span class="title">GetFloatValue</span>(<span class="params"><span class="keyword">string</span> section, <span class="keyword">string</span> variable</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span> (dataDict.ContainsKey(section) &amp;&amp; dataDict[section].ContainsKey(variable))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">string</span> rawValue = dataDict[section][variable];</span><br><span class="line">            <span class="keyword">float</span> <span class="keyword">value</span> = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">float</span>.TryParse(rawValue, <span class="keyword">out</span> <span class="keyword">value</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">value</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Debug.LogErrorFormat(<span class="string">"解析 &#123;0&#125; 部分的 &#123;1&#125; float 值出错"</span>, section, variable);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">string</span> <span class="title">GetStringValue</span>(<span class="params"><span class="keyword">string</span> variable</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> GetStringValue(<span class="string">"Global"</span>, variable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">string</span> <span class="title">GetStringValue</span>(<span class="params"><span class="keyword">string</span> section, <span class="keyword">string</span> variable</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span> (dataDict.ContainsKey(section) &amp;&amp; dataDict[section].ContainsKey(variable))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">string</span> rawValue = dataDict[section][variable];</span><br><span class="line">            <span class="keyword">return</span> rawValue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Debug.LogErrorFormat(<span class="string">"解析 &#123;0&#125; 部分的 &#123;1&#125; string 值出错"</span>, section, variable);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">string</span>.Empty;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">GetBoolValue</span>(<span class="params"><span class="keyword">string</span> variable</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> GetBoolValue(<span class="string">"Global"</span>, variable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">GetBoolValue</span>(<span class="params"><span class="keyword">string</span> section, <span class="keyword">string</span> variable</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span> (dataDict.ContainsKey(section) &amp;&amp; dataDict[section].ContainsKey(variable))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">string</span> rawValue = dataDict[section][variable].ToLower();</span><br><span class="line">            <span class="keyword">bool</span> <span class="keyword">value</span> = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">bool</span>.TryParse(rawValue, <span class="keyword">out</span> <span class="keyword">value</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">value</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Debug.LogErrorFormat(<span class="string">"解析 &#123;0&#125; 部分的 &#123;1&#125; bool 值出错"</span>, section, variable);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/Solleter/Unity3DSimpleConfig" target="_blank" rel="noopener">https://github.com/Solleter/Unity3DSimpleConfig</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在游戏开发过程中，有一些简单的配置，不需要走表，使用一个文本文件去配置，更方便。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 配置文件格式如下，[Config.txt]&lt;/strong&gt;，文件名自己定义&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;ta
      
    
    </summary>
    
    
      <category term="游戏开发" scheme="https://solleter.me/tags/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>游戏多语言实现思路</title>
    <link href="https://solleter.me/2019/10/08/%E6%B8%B8%E6%88%8F%E5%A4%9A%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E5%AE%9E%E8%B7%AF/"/>
    <id>https://solleter.me/2019/10/08/游戏多语言实现实路/</id>
    <published>2019-10-08T05:09:14.000Z</published>
    <updated>2019-10-10T14:55:45.857Z</updated>
    
    <content type="html"><![CDATA[<p>游戏多语言是指界面或者游戏中的文本根据不同的语言设置，显示不同的语言文本。</p><p>这里要说的思路是通过配置表的形式，来做多语言逻辑。首先，需要建立一个表，第一列为ID，值可以随便定义，只要保证唯一就可以。第二列为中文，第三列为英文，如果有其他的语言需求，只要加列就可以。</p><p><img src="https://i.loli.net/2019/10/08/wGacy8rM15IhZvg.png" width="100%" align="center"></p><p>写一个多语言数据管理的类，游戏运行时，将多语言表加载，并存到字典中。在游戏中，所有用到多语言的地方，都要通过ID去获取对应的文本，在获取函数中，通过判断当前设置的语言，返回对应语言的文本。例如，要获取 <strong>”新游戏“</strong> 这个按钮的文本，如果当前设置中设置的是日语，则会返回 <strong>”新しいゲーム“</strong>。</p><p>多语言表，可以由策划去维护，不同策划负责不同模块，由他们将自己负责的模块中要用到的多语言配置在表中，然后将对应的ID告诉程序，由程序将ID硬编码在逻辑中。ID一旦确定，则不能修改。</p><p>UI模块，如果要动态刷新，可以通过事件的形式，当玩家在设置模块中修改了语言，则广播出一个事件去，所有UI监听这个事件，当收到这个事件时，就重新获取一遍多语言文本，然后刷新UI。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;游戏多语言是指界面或者游戏中的文本根据不同的语言设置，显示不同的语言文本。&lt;/p&gt;
&lt;p&gt;这里要说的思路是通过配置表的形式，来做多语言逻辑。首先，需要建立一个表，第一列为ID，值可以随便定义，只要保证唯一就可以。第二列为中文，第三列为英文，如果有其他的语言需求，只要加列就可
      
    
    </summary>
    
    
      <category term="游戏开发" scheme="https://solleter.me/tags/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>统计学笔记01</title>
    <link href="https://solleter.me/2019/10/07/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E7%AC%94%E8%AE%B001/"/>
    <id>https://solleter.me/2019/10/07/统计学笔记01/</id>
    <published>2019-10-07T14:15:43.000Z</published>
    <updated>2019-10-07T14:25:05.510Z</updated>
    
    <content type="html"><![CDATA[<p>这一节笔记涉及到的概念有 <code>均值</code>，<code>中位数</code>，<code>众数</code>，<code>极差</code>，<code>中程数</code>，<code>总体均值</code>，<code>样本均值</code>，<code>离群值</code>。</p><h2 id="1-均值"><a href="#1-均值" class="headerlink" title="1. 均值"></a>1. 均值</h2><p>所有数之和除以数的个数</p><h2 id="2-中位数"><a href="#2-中位数" class="headerlink" title="2. 中位数"></a>2. 中位数</h2><p>所有数从小到大排序，中间的那个数。如果数的总数为偶数，则为中间两个数的平均数</p><h2 id="3-众数"><a href="#3-众数" class="headerlink" title="3. 众数"></a>3. 众数</h2><p>出现次数最多的那个数</p><h2 id="4-极差"><a href="#4-极差" class="headerlink" title="4. 极差"></a>4. 极差</h2><p>最大与最小数之和</p><h2 id="5-中程数"><a href="#5-中程数" class="headerlink" title="5. 中程数"></a>5. 中程数</h2><p>最大与最小数之和除以2</p><h2 id="6-总体均值"><a href="#6-总体均值" class="headerlink" title="6. 总体均值"></a>6. 总体均值</h2><p>总数数据的均值</p><h2 id="7-样本均值"><a href="#7-样本均值" class="headerlink" title="7. 样本均值"></a>7. 样本均值</h2><p>从总体数据中抽样出的部分数据，然后计算这部分数据的均值</p><h2 id="8-离群值"><a href="#8-离群值" class="headerlink" title="8. 离群值"></a>8. 离群值</h2><p>一组数据中，某些值明显与其他值相差很大，这种数据叫做离群值，例如 <code>3, 3, 3, 3, 3, 3, 100</code> 这一组数中，100明显与其他值相差很大，100就是离群值，如果这一组数计算算术平均数，则这个平均数无法反应数据的集中趋势。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这一节笔记涉及到的概念有 &lt;code&gt;均值&lt;/code&gt;，&lt;code&gt;中位数&lt;/code&gt;，&lt;code&gt;众数&lt;/code&gt;，&lt;code&gt;极差&lt;/code&gt;，&lt;code&gt;中程数&lt;/code&gt;，&lt;code&gt;总体均值&lt;/code&gt;，&lt;code&gt;样本均值&lt;/code&gt;，&lt;code&gt;
      
    
    </summary>
    
      <category term="统计学笔记" scheme="https://solleter.me/categories/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="统计学" scheme="https://solleter.me/tags/%E7%BB%9F%E8%AE%A1%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>使用外部工具登录Google VPS</title>
    <link href="https://solleter.me/2019/09/29/%E4%BD%BF%E7%94%A8%E5%A4%96%E9%83%A8%E5%B7%A5%E5%85%B7%E7%99%BB%E5%BD%95Google-VPS/"/>
    <id>https://solleter.me/2019/09/29/使用外部工具登录Google-VPS/</id>
    <published>2019-09-29T02:04:23.000Z</published>
    <updated>2019-10-07T13:48:22.231Z</updated>
    
    <content type="html"><![CDATA[<p>Google的VPS创建好后，默认是无法通过外部的工具ssh登录的，要使用外部SSH工具登录，需要修改ssh的配置。</p><ol><li><p>首先在VM实例页面，使用Google网页上的SSH进行登录</p><p><img src="https://i.loli.net/2019/09/29/rG5NiBKqHA3bTPg.png" alt="1.png"></p></li><li><p>登录后，执行命令 <code>sudo -i</code> 切换到 <code>root</code> 用户</p></li><li><p>使用 <code>passwd root</code> 命令，设置 <code>root</code> 用户登录密码</p></li><li><p>修改 <code>/etc/ssh/sshd_config</code> 文件，要修改的两行内容如下</p><blockquote><p>PermitRootLogin yes</p><p>PasswordAuthentication yes</p></blockquote></li><li><p>使用命令 <code>/etc/init.d/ssh restart</code> 重启ssh服务</p></li></ol><p>好了，现在就可以使用外部的ssh工具进行VPS的登录了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Google的VPS创建好后，默认是无法通过外部的工具ssh登录的，要使用外部SSH工具登录，需要修改ssh的配置。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;首先在VM实例页面，使用Google网页上的SSH进行登录&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.
      
    
    </summary>
    
      <category term="记录" scheme="https://solleter.me/categories/%E8%AE%B0%E5%BD%95/"/>
    
    
  </entry>
  
  <entry>
    <title>Rust基础学习-14-HashMap的基本应用</title>
    <link href="https://solleter.me/2019/09/26/Rust%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0-14-HashMap%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%BA%94%E7%94%A8/"/>
    <id>https://solleter.me/2019/09/26/Rust基础学习-14-HashMap的基本应用/</id>
    <published>2019-09-26T09:57:30.000Z</published>
    <updated>2019-10-10T14:55:45.857Z</updated>
    
    <content type="html"><![CDATA[<p><code>HashMap</code> 用于存储键值对，类似于其他编程语言中的字典。在标准库的定义是 <code>HashMap&lt;K, V&gt;</code> ，下面将用代码解释 <code>HashMap</code> 的基本使用。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="comment">// 先定义一个hashmap, 然后插入值</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> scores = HashMap::new();</span><br><span class="line">    scores.insert(<span class="number">1001</span>, <span class="number">100</span>);</span><br><span class="line">    scores.insert(<span class="number">1002</span>, <span class="number">200</span>);</span><br><span class="line">    scores.insert(<span class="number">1003</span>, <span class="number">300</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"原始map: &#123;:?&#125;"</span>, scores);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否存在某个Key</span></span><br><span class="line">    <span class="keyword">let</span> has1001 = scores.contains_key(&amp;<span class="number">1001</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"是否有key 1001: &#123;&#125;"</span>, has1001);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除一个值，参数是key的引用</span></span><br><span class="line">    scores.remove(&amp;<span class="number">1001</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"移除 1001 后: &#123;:?&#125;"</span>, scores);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入一个已经存在的值将覆盖原有值</span></span><br><span class="line">    scores.insert(<span class="number">1002</span>, <span class="number">101</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"覆盖 1002的值: &#123;:?&#125;"</span>, scores);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果一个键不存在，则插入新的键值对，如果存在，则什么也不做</span></span><br><span class="line">    scores.entry(<span class="number">1002</span>).or_insert(<span class="number">500</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"如果 1002 不存在，则插入key 1002, value 500: &#123;:?&#125;"</span>, scores);</span><br><span class="line"></span><br><span class="line">    scores.entry(<span class="number">1004</span>).or_insert(<span class="number">700</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"如果 1004 不存在，则插入key 1004, value 700: &#123;:?&#125;"</span>, scores);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取一个键的值，如果存在，返回类型是枚举 Option&lt;T&gt;</span></span><br><span class="line">    <span class="comment">// 如果有值，则返回值Some(T)，没有则返回None</span></span><br><span class="line">    <span class="keyword">let</span> value_1004 = scores.get(&amp;<span class="number">1004</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"获取1004的value: &#123;:?&#125;"</span>, value_1004);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> value_2000 = scores.get(&amp;<span class="number">2000</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"获取2000的value: &#123;:?&#125;"</span>, value_2000);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先获取原始值，的引用，然后改变原始值</span></span><br><span class="line">    <span class="keyword">let</span> value_1003 = scores.entry(<span class="number">1003</span>).or_insert(<span class="number">0</span>);</span><br><span class="line">    *value_1003 += <span class="number">54</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"在原始1003的值的基础上，加上54: &#123;:?&#125;"</span>, scores);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码使用最基本的拷贝类型 <code>i32</code> 作为键和值解释了一个 <code>HashMap</code> 基本的方法应用，更详细的方法可以参考 <a href="https://doc.rust-lang.org/std/collections/struct.HashMap.html" target="_blank" rel="noopener">HashMap的文档</a></p><p>下面看一下以<code>String</code>类型作为 key 和 value 会怎么样</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> key = <span class="string">"Jack"</span>.to_string();</span><br><span class="line">    <span class="keyword">let</span> value = <span class="string">"上海市浦东新区"</span>.to_string();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> map:HashMap&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt; = HashMap::new();</span><br><span class="line">    map.insert(key, value);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"map: &#123;:?&#125;"</span>, map);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// println!("&#123;&#125; &#123;&#125;", key, value);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，看最后一句被注释掉的代码，如果去掉注释，将编译出错，因为我们定义的 <strong>key</strong> 和 <strong>value</strong> 是<code>String</code>类型的，在插入到 <strong>hashmap</strong> 后，<strong>key</strong> 和 <strong>value</strong> 的的所有权将移动到 <strong>hashmap</strong> 中，所以再访问就会出错。</p><p>上面第<strong>7</strong>行代码，定义一个 <code>HashMap</code> 时，我们给map变量指定了具体的<code>HashMap</code>类型，这里不指定也行，Rust会根据上下文自动推断中 <code>HashMap</code> 中存储的数据类型。</p><p><code>let mut map = HashMap::new();</code></p><p>这里只是简单地介绍了一下 <code>HashMap</code> 的一些应用，更复杂的使用将在后面的博客中详细介绍。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;HashMap&lt;/code&gt; 用于存储键值对，类似于其他编程语言中的字典。在标准库的定义是 &lt;code&gt;HashMap&amp;lt;K, V&amp;gt;&lt;/code&gt; ，下面将用代码解释 &lt;code&gt;HashMap&lt;/code&gt; 的基本使用。&lt;/p&gt;
&lt;figure cl
      
    
    </summary>
    
      <category term="Rust 基础学习" scheme="https://solleter.me/categories/Rust-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Rust" scheme="https://solleter.me/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>Rust基础学习-13-再聊一下String</title>
    <link href="https://solleter.me/2019/09/26/Rust%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0-13-%E5%86%8D%E8%81%8A%E4%B8%80%E4%B8%8BString/"/>
    <id>https://solleter.me/2019/09/26/Rust基础学习-13-再聊一下String/</id>
    <published>2019-09-26T02:14:56.000Z</published>
    <updated>2019-10-10T14:55:45.857Z</updated>
    
    <content type="html"><![CDATA[<p>之前我们已经使用过 <code>String</code>，对于 <code>String</code> 的解释是可增长的、可变的、有所有权的、UTF-8 编码的字符串类型。<code>String</code> 的数据是存在于堆上的。下面再看一些关于 <code>String</code> 的使用。</p><p><strong>1. 创建字符串</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="comment">// 创建一个字符串</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> s1 = <span class="built_in">String</span>::new();</span><br><span class="line">    s1.push_str(<span class="string">"Hello"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> s2 = <span class="built_in">String</span>::from(<span class="string">"Hello"</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> s3 = <span class="string">"Hello"</span>.to_string();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上面 s1，s2，s3分别创建了一个字符串，并填充内容 “Hello”，这三种方式都可以达到相同的目的。</p></blockquote><p><strong>2. 除上可以 <code>push_str</code> ，还可以 <code>push</code> 单个字符</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> s1 = <span class="built_in">String</span>::new();</span><br><span class="line">    s1.push(<span class="string">'H'</span>);</span><br><span class="line">    s1.push(<span class="string">'e'</span>);</span><br><span class="line">    s1.push(<span class="string">'l'</span>);</span><br><span class="line">    s1.push(<span class="string">'l'</span>);</span><br><span class="line">    s1.push(<span class="string">'o'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3.字符串的拼接</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> s1 = <span class="string">"Hello"</span>.to_string();</span><br><span class="line">    <span class="keyword">let</span> s2 = <span class="string">", Rust"</span>.to_string();</span><br><span class="line">    <span class="keyword">let</span> s3 = <span class="string">" Haha"</span>.to_string();</span><br><span class="line">    <span class="keyword">let</span> s4 = s1 + &amp;s2 + &amp;s3;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"s2: &#123;&#125;\ns3: &#123;&#125;\ns4: &#123;&#125;"</span>,  s2, s3, s4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意，如果要使用 <code>+</code> 去拼接字符串，会先获得第一个变量的所有权，然后附加上后面变量的内容拷贝。上面的代码，s4 创建后，s1将不再有效。</p></blockquote><p><strong>4. 使用 <code>format!</code> 宏拼接字符串</strong></p><p>在涉及到很多的字符串要拼接时，使用 <code>+</code> 就不那么方便，下面使用 <code>format!</code> 宏进行操作，就方便很多。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> s1 = <span class="string">"Hello"</span>.to_string();</span><br><span class="line">    <span class="keyword">let</span> s2 = <span class="string">", Rust"</span>.to_string();</span><br><span class="line">    <span class="keyword">let</span> s3 = <span class="string">" Haha"</span>.to_string();</span><br><span class="line">    <span class="keyword">let</span> s4 = <span class="built_in">format!</span>(<span class="string">"&#123;&#125;-&#123;&#125;-&#123;&#125;"</span>, s1, s2, s3);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"s1: &#123;&#125;\ns2: &#123;&#125;\ns3: &#123;&#125;\ns4: &#123;&#125;"</span>, s1, s2, s3, s4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>从上面可以看出，<code>format!</code> 宏在拼接字符串时，并不获取任何所有权</p></blockquote><p><strong>5. 获取字符串的长度</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> s1 = <span class="string">"Hello"</span>.to_string();</span><br><span class="line">    <span class="keyword">let</span> len = s1.len();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>6. 字符串的遍历</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> s1 = <span class="string">"Hello"</span>.to_string();</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">char</span> <span class="keyword">in</span> s1.chars()&#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, <span class="built_in">char</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>String</code> 不支持以 <code>[0]</code> 这样的索引形式访问单个字符，具体原因请看后面关于 <code>String</code> 的详细内容连接。但是 <code>String</code> 可以用上面的形式遍历每一个字符。</p></blockquote><p><strong>7. 字符串原始字节遍历</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">for</span> b <span class="keyword">in</span> <span class="string">"नमस्ते"</span>.bytes() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="上面只是讨论-String-很基本的使用，但是-String-并不简单，里面还有很多很多内容，具体到里面的一些原理和实现，请阅读下面的连接"><a href="#上面只是讨论-String-很基本的使用，但是-String-并不简单，里面还有很多很多内容，具体到里面的一些原理和实现，请阅读下面的连接" class="headerlink" title="上面只是讨论 String 很基本的使用，但是 String 并不简单，里面还有很多很多内容，具体到里面的一些原理和实现，请阅读下面的连接"></a>上面只是讨论 <code>String</code> 很基本的使用，但是 <code>String</code> 并不简单，里面还有很多很多内容，具体到里面的一些原理和实现，请阅读下面的连接</h4><p>Rust 程序语言设计 <a href="https://kaisery.github.io/trpl-zh-cn/ch08-02-strings.html" target="_blank" rel="noopener">https://kaisery.github.io/trpl-zh-cn/ch08-02-strings.html</a></p><p>String 官方文档 <a href="https://doc.rust-lang.org/std/string/struct.String.html" target="_blank" rel="noopener">https://doc.rust-lang.org/std/string/struct.String.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前我们已经使用过 &lt;code&gt;String&lt;/code&gt;，对于 &lt;code&gt;String&lt;/code&gt; 的解释是可增长的、可变的、有所有权的、UTF-8 编码的字符串类型。&lt;code&gt;String&lt;/code&gt; 的数据是存在于堆上的。下面再看一些关于 &lt;code&gt;Stri
      
    
    </summary>
    
      <category term="Rust 基础学习" scheme="https://solleter.me/categories/Rust-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Rust" scheme="https://solleter.me/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>Rust基础学习-12-vector的使用</title>
    <link href="https://solleter.me/2019/09/22/Rust%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0-12-vector%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://solleter.me/2019/09/22/Rust基础学习-12-vector的使用/</id>
    <published>2019-09-22T09:02:23.000Z</published>
    <updated>2019-09-22T09:54:45.576Z</updated>
    
    <content type="html"><![CDATA[<p>这一篇博客我们来聊一下Rust中 <strong>vector</strong> 的使用。<strong>vector</strong> 就像数组一样，用于存储同一类型的一系列的值，但是允许动态地添加和删除值，以及拥有一些其他的方法。</p><h2 id="vector-的定义"><a href="#vector-的定义" class="headerlink" title="vector 的定义"></a>vector 的定义</h2><p>在代码中，使用 <code>Vec&lt;T&gt;</code> 来定义一个 vector 类型的变量</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">  <span class="comment">// 这一个可以动态添加和删除元素</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> vec1: <span class="built_in">Vec</span>&lt;<span class="built_in">u32</span>&gt; = <span class="built_in">Vec</span>::new();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 在定义的时候就填充好值，因为没有mut，所以无法动态添加和删除</span></span><br><span class="line">  <span class="keyword">let</span> vec2 = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">  <span class="keyword">let</span> vec3 = <span class="built_in">vec!</span>[<span class="string">"str1"</span>, <span class="string">"str2"</span>, <span class="string">"str3"</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>vec!</code> 是rust提供的宏，可以动态地根据我们的数据，自动推断出这个 vector 变量的类型</p></blockquote><h2 id="添加和删除元素"><a href="#添加和删除元素" class="headerlink" title="添加和删除元素"></a>添加和删除元素</h2><p>向 <strong>vector</strong> 中添加元素，使用 <code>push</code> 方法，从vector中删除最后添加的元素，使用 <code>pop</code> 方法</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> nums: <span class="built_in">Vec</span>&lt;<span class="built_in">u32</span>&gt; = <span class="built_in">Vec</span>::new();</span><br><span class="line">    nums.push(<span class="number">10</span>);</span><br><span class="line">    nums.push(<span class="number">11</span>);</span><br><span class="line">    nums.push(<span class="number">12</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, nums); <span class="comment">// 打印出 [10, 11, 12]</span></span><br><span class="line">    nums.pop(); <span class="comment">// 将最后的元素拿出来丢了</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, nums); <span class="comment">// 这里打印出 [10, 11]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>pop</code> 会将值返回，返回的类型是 <code>Option&lt;T&gt;</code> 类型，我们可以定义一个变量接收 pop 出来的值</p></blockquote><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> nums: <span class="built_in">Vec</span>&lt;<span class="built_in">u32</span>&gt; = <span class="built_in">Vec</span>::new();</span><br><span class="line">    nums.push(<span class="number">10</span>);</span><br><span class="line">    nums.push(<span class="number">11</span>);</span><br><span class="line">    nums.push(<span class="number">12</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, nums);</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">let</span> x = nums.pop();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"x: &#123;:?&#125;"</span>, x);  <span class="comment">// 这里将打印出 Some(12)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果 vector 中已经没有元素，继续使用 <code>pop</code>，将返回 <code>Option&lt;T&gt;</code> 中的 <code>None</code></p></blockquote><h2 id="访问特定所以呢的元素"><a href="#访问特定所以呢的元素" class="headerlink" title="访问特定所以呢的元素"></a>访问特定所以呢的元素</h2><p>就像数组一样，vector也可以使用 <code>[index]</code> 这样的形式去访问某个元素，还可以使用 <code>get(index)</code> 方法访问。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> nums: <span class="built_in">Vec</span>&lt;<span class="built_in">u32</span>&gt; = <span class="built_in">Vec</span>::new();</span><br><span class="line">    nums.push(<span class="number">10</span>);</span><br><span class="line">    nums.push(<span class="number">11</span>);</span><br><span class="line">    nums.push(<span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里获取的是第0个元素的引用</span></span><br><span class="line">    <span class="keyword">let</span> first_num = &amp;nums[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"first_num: &#123;&#125;"</span>, first_num);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get 方法在这里返回的 Option&lt;&amp;u32&gt;</span></span><br><span class="line">    <span class="keyword">let</span> second_num = nums.get(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"x:&#123;:?&#125;"</span>, second_num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果我们尝试访问越界索引的元素会怎样呢？如果使用 <code>[index]</code> 这种形式，Rust 会直接导致 panic 然后退出进程，如果使用 <code>get(index)</code> 这种形式，Rust会返回 <code>Option&lt;T&gt;</code> 中的 <code>None</code></p></blockquote><p><strong>为什么这里获取值的时候，要获取它引用，而不是值本身呢？对于 copy 类型的数据，似乎没有什么区别，但是对于 String 这样类型的数据，如果我们直接获取值，就会导致所有权的移动。看下面的遍历代码</strong></p><h2 id="遍历-vector"><a href="#遍历-vector" class="headerlink" title="遍历 vector"></a>遍历 vector</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> names: <span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt; = <span class="built_in">Vec</span>::new();</span><br><span class="line">    names.push(<span class="string">"Jack"</span>.to_string());</span><br><span class="line">    names.push(<span class="string">"Tony"</span>.to_string());</span><br><span class="line">    names.push(<span class="string">"Tina"</span>.to_string());</span><br><span class="line">    <span class="comment">// 遍历vector中每一个元素，然后打印出来</span></span><br><span class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> &amp;names &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"name: &#123;&#125;"</span>, name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印出整个vector来</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"names: &#123;:?&#125;"</span>, names);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码，如果我们把第<code>7</code>行改为 <code>for name in names</code> 那么这段代码就会<code>编译不过</code>，因为 vector 中的值的所有权，已经移动到了 println 中的 name 变量，所以在第12行再次访问的时候，就会出错，所以编译器会直接编译不过。<strong>所以，在获取和遍历 vector 中值的时候，一定要注意所有权转移的问题</strong></p><h2 id="在-vector-中存储不同类型的值"><a href="#在-vector-中存储不同类型的值" class="headerlink" title="在 vector 中存储不同类型的值"></a>在 vector 中存储不同类型的值</h2><p>在博客开始的时候我们说 vector 只能存储相同类型的值，这是没错的。这里我们存储不同类型的值，是使用了上一篇讲到的枚举类型而做到的。看下面的代码</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Data</span></span> &#123;</span><br><span class="line">    IData(<span class="built_in">i32</span>),</span><br><span class="line">    FData(<span class="built_in">f32</span>),</span><br><span class="line">    SData(<span class="built_in">String</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> data_sets: <span class="built_in">Vec</span>&lt;Data&gt; = <span class="built_in">Vec</span>::new();</span><br><span class="line">    data_sets.push(Data::IData(<span class="number">10</span>));</span><br><span class="line">    data_sets.push(Data::FData(<span class="number">3.14159</span>));</span><br><span class="line">    data_sets.push(Data::SData(<span class="built_in">String</span>::from(<span class="string">"Hello Rust"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先定义一个拥有多种数据类型的枚举，然后定义一个存储这种枚举类型的 vector，这样就实现了一个 vector 中存储不同类型的数据。</p><p><a href="https://doc.rust-lang.org/std/vec/struct.Vec.html" target="_blank" rel="noopener">Vec详细使用时，可以参考源代码的文档</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这一篇博客我们来聊一下Rust中 &lt;strong&gt;vector&lt;/strong&gt; 的使用。&lt;strong&gt;vector&lt;/strong&gt; 就像数组一样，用于存储同一类型的一系列的值，但是允许动态地添加和删除值，以及拥有一些其他的方法。&lt;/p&gt;
&lt;h2 id=&quot;vector-
      
    
    </summary>
    
      <category term="Rust 基础学习" scheme="https://solleter.me/categories/Rust-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Rust" scheme="https://solleter.me/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>Rust基础学习-11-枚举的使用</title>
    <link href="https://solleter.me/2019/09/21/Rust%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0-11-%E6%9E%9A%E4%B8%BE%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://solleter.me/2019/09/21/Rust基础学习-11-枚举的使用/</id>
    <published>2019-09-21T05:51:19.000Z</published>
    <updated>2019-09-21T08:01:04.971Z</updated>
    
    <content type="html"><![CDATA[<p>枚举 <code>enum</code>，用于从众多选项中选择一个。 </p><h2 id="定义枚举"><a href="#定义枚举" class="headerlink" title="定义枚举"></a>定义枚举</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Week</span></span> &#123;</span><br><span class="line">    Monday,</span><br><span class="line">    Tuesday,</span><br><span class="line">    Wednesday,</span><br><span class="line">    Thursday,</span><br><span class="line">    Friday,</span><br><span class="line">    Saturday,</span><br><span class="line">    Sunday,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> today = Week::Saturday;  <span class="comment">// 使用枚举</span></span><br><span class="line">    <span class="keyword">let</span> tomorrow = Week::Sunday;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, today);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是我们在很多面向对象语言中常见的定义枚举的方式</p><blockquote><p>以往对枚举的认识，就是枚举限定了几个固定的选项，我们只能使用众多选项中的一个，或者说，只是使用了某一个元素的名字，例如上面Week枚举中的Monday，至于Monday是什么，无所谓，Monday = 1也好，Monday = 10也好，我们并不关心。但是对于Rust，我们对枚举有更进一步的应用。</p></blockquote><h2 id="用枚举代替结构体"><a href="#用枚举代替结构体" class="headerlink" title="用枚举代替结构体"></a>用枚举代替结构体</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">IpAddr</span></span> &#123;</span><br><span class="line">    V4(<span class="built_in">u8</span>, <span class="built_in">u8</span>, <span class="built_in">u8</span>, <span class="built_in">u8</span>), <span class="comment">// 这个枚举成员是四个u8类型的元祖</span></span><br><span class="line">    V6(<span class="built_in">String</span>), <span class="comment">// 这个枚举成员是String类型</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="comment">// 定义一个枚举变量，并将四个值存放</span></span><br><span class="line">    <span class="keyword">let</span> loopbackV4 = IpAddr::V4(<span class="number">127</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 定义另一个枚举变量，存入一个 String 类型的值</span></span><br><span class="line">    <span class="comment">// "xxx".to_string() 方法和 String::from("xxx") 是一样的效果</span></span><br><span class="line">    <span class="keyword">let</span> loopbackV6 = IpAddr::V6(<span class="string">"::1"</span>.to_string());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;\n&#123;:?&#125;"</span>, loopbackV4, loopbackV6);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码，我们可以给枚举的每一个成员，指定一个数据类型，并且在创建一个枚举变量的时候，将某个值存入枚举。在 <code>struct</code> 中可以存储不同类型的变量，现在，在枚举中也可以。</p><p>再来看一个例子</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个操作枚举</span></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Operation</span></span> &#123;</span><br><span class="line">    Move &#123;x: <span class="built_in">i32</span>, y:<span class="built_in">i32</span>&#125;,</span><br><span class="line">    Jump(<span class="built_in">u32</span>),</span><br><span class="line">    Attack(<span class="built_in">i32</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="comment">// 定义一个移动的操作</span></span><br><span class="line">    <span class="keyword">let</span> opt_move = Operation::Move &#123;x: <span class="number">10</span>, y: <span class="number">11</span>&#125;;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 定义一个攻击的操作</span></span><br><span class="line">    <span class="keyword">let</span> opt_attack = Operation::Attack(<span class="number">100</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 定义一个跳跃的操作</span></span><br><span class="line">    <span class="keyword">let</span> opt_jump = Operation::Jump(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    DoOperation(opt_move);</span><br><span class="line">    DoOperation(opt_attack);</span><br><span class="line">    DoOperation(opt_jump);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行操作</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">DoOperation</span></span>(opt: Operation) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Do operation: &#123;:?&#125;"</span>, opt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码我们定义了一个 <strong>Operation</strong> 枚举，里面有移动，攻击和跳跃三种操作方式。在 <strong>main</strong> 中定义了三个操作的变量，并且将每一次操作的具体值直接附加到了枚举成员上，例如 opt_attack 攻击操作，这次操作的伤害是100。</p><blockquote><p>Rust 中使用 <code>enum</code> 代替 <code>struct</code> 将获得更简洁的代码。并且，每个枚举成员可以处理不同类型和数量的数据。</p></blockquote><h2 id="Rust-的-Option-枚举解释"><a href="#Rust-的-Option-枚举解释" class="headerlink" title="Rust 的 Option 枚举解释"></a>Rust 的 Option 枚举解释</h2><p>Rust 中没有 <code>Null</code> 值，无法将一个变量赋值为 <code>Null</code>, 例如 <code>let a = Null;</code>，这样的操作在Rust中不存在。但是Rust中有 <code>Option</code> 枚举，这个枚举，用于表示 <code>存在</code> 与 <code>不存在</code> 的概念。有点抽象，没关系，一步一步来，先看下 <code>Option</code> 源代码的定义</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Option</span></span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="literal">Some</span>(T),</span><br><span class="line">  <span class="literal">None</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 <code>&lt;T&gt;</code> 是指可以代表任何数据类型的，这是范型相关的东西，后面会学习。可以将 <code>Option</code> 枚举想象成可以装不同类型东西的小盒子，例如我们定义了一个装玩具汽车的小盒子，这个小盒子里只能装玩具汽车。任何时候，只要这个盒子存在，那么里面就会有两种状态，要么有玩具汽车，要么没有玩具汽车。在有些面向对象的语言中，如果访问一个玩具汽车，而恰好当时那里没有玩具汽车，那么就会造成<code>空引用</code>，如果没有手动处理空引用的情况，则程序就会出现Bug。而Rust则避免了 <code>空引用</code> 的情况。</p><p>看下面的代码</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">  <span class="comment">// 使用 Option 将一个 String 类型的值包起来</span></span><br><span class="line">  <span class="keyword">let</span> name: <span class="built_in">Option</span>&lt;<span class="built_in">String</span>&gt; = <span class="literal">Some</span>(<span class="string">"Fred"</span>.to_string());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>Option</code> 用于某些地方可能存在有值或没值的情况。Option 及成员已经被自动包含，所以我们不需要 <code>Option::Some(xxx)</code> 这样来使用。</p></blockquote><h2 id="match-匹配"><a href="#match-匹配" class="headerlink" title="match 匹配"></a>match 匹配</h2><p>对于 <code>enum</code> 类型的值，我们不能直接比较，看下面的代码，是无法编译通过的。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">let</span> name: <span class="built_in">Option</span>&lt;<span class="built_in">String</span>&gt; = <span class="built_in">Option</span>::<span class="literal">Some</span>(<span class="string">"Jack"</span>.to_string());</span><br><span class="line"><span class="built_in">println!</span>(name == <span class="string">"Jack"</span>.to_string());</span><br></pre></td></tr></table></figure><p>上面代码中 <code>name == &quot;Jack&quot;.to_string()</code> 编译出错，因为 == 两边的数据类型不一样。这里，我们就可以用到 <code>match</code>。</p><p>看下面的代码</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Operation</span></span> &#123;</span><br><span class="line">    Move &#123;x: <span class="built_in">i32</span>, y:<span class="built_in">i32</span>&#125;,</span><br><span class="line">    Jump(<span class="built_in">u32</span>),</span><br><span class="line">    Attack(<span class="built_in">i32</span>),</span><br><span class="line">    Talk(<span class="built_in">String</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> opt_talk = Operation::Talk(<span class="string">"Hello"</span>.to_string());</span><br><span class="line">    <span class="keyword">let</span> opt_move = Operation::Move &#123; x: <span class="number">10</span>, y: <span class="number">20</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> opt_move &#123;</span><br><span class="line">        Operation::Talk(<span class="keyword">ref</span> value) =&gt; &#123; <span class="comment">// 这里加了 ref 是为了避免所有权转移</span></span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"Talk: &#123;:?&#125;"</span>, value);</span><br><span class="line">        &#125;,</span><br><span class="line">        Operation::Move &#123;x,y&#125; =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"Move, x: &#123;&#125;, y: &#123;&#125;"</span>, x, y);</span><br><span class="line">        &#125;</span><br><span class="line">        _ =&gt; &#123;</span><br><span class="line">            <span class="comment">// nothing</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中，match Operation 枚举时，并没有匹配所有的情况，所以最后需要 <code>_ =&gt;</code> ，相当于某些编译语言中 <code>switch 中的 default</code>，即在上面的情况都不匹配的情况下，执行的操作。</p><h2 id="if-let-使用"><a href="#if-let-使用" class="headerlink" title="if let 使用"></a>if let 使用</h2><p>直接看代码，简化上面 <code>match</code> 的操作</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> Operation::Move&#123;x, y&#125; = opt_move &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Move, x: &#123;&#125;, y: &#123;&#125;"</span>, x, y);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"nothing"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就可以不用 <code>match</code> 直接匹配枚举中的某一个成员类型。</p><p>感觉这篇博客有些地方写的可能不是很清楚，说明我对这块知识的理解程度还不够。下面是一些讲解 Rust 枚举的链接</p><p><a href="https://rustwiki.org/zh-CN/rust-by-example/custom_types/enum.html" target="_blank" rel="noopener">https://rustwiki.org/zh-CN/rust-by-example/custom_types/enum.html</a></p><p><a href="https://www.twle.cn/c/yufei/rust/rust-basic-enums.html" target="_blank" rel="noopener">https://www.twle.cn/c/yufei/rust/rust-basic-enums.html</a></p><p><a href="http://www.ameyalokare.com/rust/2017/10/23/rust-options.html" target="_blank" rel="noopener">http://www.ameyalokare.com/rust/2017/10/23/rust-options.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;枚举 &lt;code&gt;enum&lt;/code&gt;，用于从众多选项中选择一个。 &lt;/p&gt;
&lt;h2 id=&quot;定义枚举&quot;&gt;&lt;a href=&quot;#定义枚举&quot; class=&quot;headerlink&quot; title=&quot;定义枚举&quot;&gt;&lt;/a&gt;定义枚举&lt;/h2&gt;&lt;figure class=&quot;highlig
      
    
    </summary>
    
      <category term="Rust 基础学习" scheme="https://solleter.me/categories/Rust-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Rust" scheme="https://solleter.me/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>Rust基础学习-10-结构体的方法</title>
    <link href="https://solleter.me/2019/09/18/Rust%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0-10-%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>https://solleter.me/2019/09/18/Rust基础学习-10-结构体的方法/</id>
    <published>2019-09-18T04:30:06.000Z</published>
    <updated>2019-09-21T05:48:25.435Z</updated>
    
    <content type="html"><![CDATA[<p>这篇博客来聊一下 <code>结构体的方法</code>，本质上就是为某个结构体而定义的方法 (函数)。拿面向对象语言来说，写了一个类，还可能会在这个类里写一些方法，基本上同样的套路。或者说，定义的这些方法，是与这个结构体有关的。</p><p>不太严谨的解释，这里所谓的方法，其实就是一个函数。</p><h2 id="结构体方法的定义"><a href="#结构体方法的定义" class="headerlink" title="结构体方法的定义"></a>结构体方法的定义</h2><p>看下面的代码</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里定义一个矩形的结构体</span></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rectangle</span></span> &#123;</span><br><span class="line">    width: <span class="built_in">u32</span>,</span><br><span class="line">    height: <span class="built_in">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里的 impl xxx 是固定的，xxx 就是你要为哪一个结构体去定义一些方法</span></span><br><span class="line"><span class="keyword">impl</span> Rectangle &#123;</span><br><span class="line">    <span class="comment">// 这是一个计算面积的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">area</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">u32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width * <span class="keyword">self</span>.height</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这是一个计算周长的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">perimeter</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">u32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width * <span class="number">2</span> + <span class="keyword">self</span>.height * <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这是一个计算能否包含另一个矩形的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">can_hold</span></span>(&amp;<span class="keyword">self</span>, other: &amp;Rectangle) -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width &gt; other.width &amp;&amp; <span class="keyword">self</span>.height &gt; other.height</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>!!! 注意看上面的代码及 <code>注释</code></p><blockquote><p>结构体的<code>方法</code> 第一个参数总是 <code>&amp;self</code> 表示定义好的结构体 <code>实例</code> 自身</p></blockquote><p>下面是使用这个结构体</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> r1 = Rectangle &#123;width: <span class="number">128</span>, height: <span class="number">90</span>&#125;;</span><br><span class="line">    <span class="keyword">let</span> r2 = Rectangle &#123;width: <span class="number">50</span>, height: <span class="number">30</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:#?&#125;"</span>, r1);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:#?&#125;"</span>, r2);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用结构体的 area() 方法</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"r area: &#123;&#125;"</span>, r1.area());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用结构体的 perimeter() 方法</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"r perimeter: &#123;&#125;"</span>, r1.perimeter());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用结构体的 can_hold() 方法</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"r1 can hold r2: &#123;&#125;"</span>, r1.can_hold(&amp;r2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意上面的代码，我们打印结构体实例的时候，以前是用 <code>{:?}</code>，而这次用的是 <code>{:#?}</code>。这是因为，使用 <code>{:#?}</code> 能以更美观的方式打印出这个结构体的数据来</p></blockquote><p>如果要定义可以修改的结构体，只要加上 <code>mut</code> 就行，看下面的代码</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> r1 = Rectangle &#123;width: <span class="number">100</span>, height: <span class="number">50</span>&#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:#?&#125;"</span>, r1);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 修改了 r1 的 width</span></span><br><span class="line">    r1.width = <span class="number">1000</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:#?&#125;"</span>, r1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="关联函数"><a href="#关联函数" class="headerlink" title="关联函数"></a>关联函数</h2><p>在 <code>impl</code>  代码块中，定义一些不以 <code>&amp;self</code> 作为参数的函数，这些函数被称为 <code>关联函数</code>。就是说，这些函数，不针对某一个具体的结构体实例，而是针对这个结构体本身。</p><p>直接看下面的代码</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rectangle</span></span> &#123;</span><br><span class="line">    width: <span class="built_in">u32</span>,</span><br><span class="line">    height: <span class="built_in">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Rectangle &#123;</span><br><span class="line">    <span class="comment">// 创建一个 矩形 实例</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(width: <span class="built_in">u32</span>, height: <span class="built_in">u32</span>) -&gt; Rectangle &#123;</span><br><span class="line">        Rectangle &#123;</span><br><span class="line">            width,</span><br><span class="line">            height,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个 正方形 实例</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">new_square</span></span>(size: <span class="built_in">u32</span>) -&gt; Rectangle &#123;</span><br><span class="line">        Rectangle &#123;</span><br><span class="line">            width: size,</span><br><span class="line">            height: size,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面代码是 <code>使用</code> <code>关联函数</code></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> r1 = Rectangle::new(<span class="number">100</span>, <span class="number">80</span>);</span><br><span class="line">    <span class="keyword">let</span> r2 = Rectangle::new_square(<span class="number">100</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:#?&#125;"</span>, r1);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:#?&#125;"</span>, r2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>对于一个结构体方法的调用，我们使用 <code>r1.area()</code> 这样的形式。而对于 <code>关联函数</code> 的调用，需要使用 <code>::</code> 这个操作符。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这篇博客来聊一下 &lt;code&gt;结构体的方法&lt;/code&gt;，本质上就是为某个结构体而定义的方法 (函数)。拿面向对象语言来说，写了一个类，还可能会在这个类里写一些方法，基本上同样的套路。或者说，定义的这些方法，是与这个结构体有关的。&lt;/p&gt;
&lt;p&gt;不太严谨的解释，这里所谓的方
      
    
    </summary>
    
      <category term="Rust 基础学习" scheme="https://solleter.me/categories/Rust-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Rust" scheme="https://solleter.me/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>Rust基础学习-09-结构体的定义</title>
    <link href="https://solleter.me/2019/09/16/Rust%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0-09-%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%AE%9A%E4%B9%89/"/>
    <id>https://solleter.me/2019/09/16/Rust基础学习-09-结构体的定义/</id>
    <published>2019-09-16T11:45:06.000Z</published>
    <updated>2019-09-21T05:48:25.434Z</updated>
    
    <content type="html"><![CDATA[<p>结构体可以用于组织不同类型的数据，和一些面向对像语言中的 <code>类</code> 是很像的。</p><p>这篇博客包含以下内容</p><ul><li>结构体的定义</li><li>通过一个函数，创建并返回一个结构体</li><li>定义一个结构体，但数据来自另外一个结构体</li><li>元祖结构体</li></ul><h2 id="结构体的定义"><a href="#结构体的定义" class="headerlink" title="结构体的定义"></a>结构体的定义</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span>  <span class="comment">// 加上这一句，就可以使用 println!("&#123;:?&#125;", xxx); 打印</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">User</span></span> &#123;</span><br><span class="line">    username: <span class="built_in">String</span>,</span><br><span class="line">    email: <span class="built_in">String</span>,</span><br><span class="line">    sign_in_count: <span class="built_in">u64</span>,</span><br><span class="line">    active: <span class="built_in">bool</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结构体以 <code>struct</code> 开头，后面是我们自定义的这个结构体类型的名字，里面每一个字段，以 <code>字段名: 数据类型</code> 的形式定义</p><blockquote><p>结构体开头那个 <code>#[derive(Debug)]</code> 是为了打印而加的，也可以不加，这个的意思会在后面章节学习到，现在我也不知道具体意思，反正加上就可以使用 <code>{:?}</code> 的形式打印。</p></blockquote><p>下面这段代码创建一个结构体实例</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> user = User &#123;</span><br><span class="line">        username: <span class="built_in">String</span>::from(<span class="string">"someone"</span>),</span><br><span class="line">        email: <span class="built_in">String</span>::from(<span class="string">"someone@outlook.com"</span>),</span><br><span class="line">        sign_in_count: <span class="number">1</span>,</span><br><span class="line">        active: <span class="literal">false</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 打印这个结构体的内容</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, user);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 因为创建 user 的时候加了 mut，所以可以修改里面字段的内容</span></span><br><span class="line">    user.active = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Changed: &#123;:?&#125;"</span>, user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="通过一个函数，创建并返回一个结构体"><a href="#通过一个函数，创建并返回一个结构体" class="headerlink" title="通过一个函数，创建并返回一个结构体"></a>通过一个函数，创建并返回一个结构体</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">build_user</span></span>(_username: <span class="built_in">String</span>, _email: <span class="built_in">String</span>) -&gt; User &#123;</span><br><span class="line">    User &#123;</span><br><span class="line">        username: _username,</span><br><span class="line">        email: _email,</span><br><span class="line">        sign_in_count: <span class="number">2</span>,</span><br><span class="line">        active: <span class="literal">false</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果参数名和结构体的字段名相同，则可以直接按下面的方式去赋值，</span></span><br><span class="line"><span class="comment">// 不需要再 aaa:bbb 这样的形式，并且顺序也无所谓</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">build_user2</span></span>(username: <span class="built_in">String</span>, email: <span class="built_in">String</span>) -&gt; User &#123;</span><br><span class="line">    User &#123;</span><br><span class="line">        email,</span><br><span class="line">        username,</span><br><span class="line">        sign_in_count: <span class="number">2</span>,</span><br><span class="line">        active: <span class="literal">false</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="定义一个结构体，但数据来自另外一个结构体"><a href="#定义一个结构体，但数据来自另外一个结构体" class="headerlink" title="定义一个结构体，但数据来自另外一个结构体"></a>定义一个结构体，但数据来自另外一个结构体</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">User</span></span> &#123;</span><br><span class="line">    username: <span class="built_in">String</span>,</span><br><span class="line">    email: <span class="built_in">String</span>,</span><br><span class="line">    sign_in_count: <span class="built_in">u64</span>,</span><br><span class="line">    active: <span class="built_in">bool</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> user = User &#123;</span><br><span class="line">        username: <span class="built_in">String</span>::from(<span class="string">"someone"</span>),</span><br><span class="line">        email: <span class="built_in">String</span>::from(<span class="string">"someone@outlook.com"</span>),</span><br><span class="line">        sign_in_count: <span class="number">1</span>,</span><br><span class="line">        active: <span class="literal">false</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, user);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">let</span> user2 = User &#123;</span><br><span class="line">        username: <span class="built_in">String</span>::from(<span class="string">"user2"</span>),</span><br><span class="line">        email: <span class="built_in">String</span>::from(<span class="string">"user2@outlook.com"</span>),</span><br><span class="line">        sign_in_count: user.sign_in_count,<span class="comment">// 使用 user 实例的数据</span></span><br><span class="line">        active: user.active,  <span class="comment">// 这个也使用 user 实例的数据</span></span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 除了 username 和 email, 其他字段都使用 user 的值</span></span><br><span class="line">    <span class="keyword">let</span> user3 = User &#123;</span><br><span class="line">        username: <span class="built_in">String</span>::from(<span class="string">"user3"</span>),</span><br><span class="line">        email: <span class="built_in">String</span>::from(<span class="string">"user3@outlook.com"</span>),</span><br><span class="line">        ..user</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码，使用其他结构体数据，创建新的结构体时，我们使用的都是 <code>简单</code> 的 <code>数据类型</code>。如果使用 String 类型的字段，例如 username 或 email，则原有结构体实例的数据，会移动到新的结构体实例。看下面的代码。</p><p>下面这段代码编译会出错。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">User</span></span> &#123;</span><br><span class="line">    username: <span class="built_in">String</span>,</span><br><span class="line">    email: <span class="built_in">String</span>,</span><br><span class="line">    sign_in_count: <span class="built_in">u64</span>,</span><br><span class="line">    active: <span class="built_in">bool</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> user = User &#123;</span><br><span class="line">        username: <span class="built_in">String</span>::from(<span class="string">"someone"</span>),</span><br><span class="line">        email: <span class="built_in">String</span>::from(<span class="string">"someone@outlook.com"</span>),</span><br><span class="line">        sign_in_count: <span class="number">1</span>,</span><br><span class="line">        active: <span class="literal">false</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> user2 = User &#123;</span><br><span class="line">        ..user</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// !!!! 这一句编译会出错，因为我们创建 user2 的时候，使用了所有 user的数据，</span></span><br><span class="line">    <span class="comment">// 因为 username 和 email是String类型的，所以 所有权 会移动到 user2的对应字段中</span></span><br><span class="line">    <span class="comment">// 所以这句就会报错 !!!</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, user.username);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要修复错误，可以使用我们上一节学到的切片，直接看下面的代码</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">User</span></span> &#123;</span><br><span class="line">    username: <span class="built_in">String</span>,</span><br><span class="line">    email: <span class="built_in">String</span>,</span><br><span class="line">    sign_in_count: <span class="built_in">u64</span>,</span><br><span class="line">    active: <span class="built_in">bool</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> user = User &#123;</span><br><span class="line">        username: <span class="built_in">String</span>::from(<span class="string">"someone"</span>),</span><br><span class="line">        email: <span class="built_in">String</span>::from(<span class="string">"someone@outlook.com"</span>),</span><br><span class="line">        sign_in_count: <span class="number">1</span>,</span><br><span class="line">        active: <span class="literal">false</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> user2 = User &#123;</span><br><span class="line">        username: <span class="built_in">String</span>::from(&amp;user.username[..]), <span class="comment">// !!! 注意看这句</span></span><br><span class="line">        email: <span class="built_in">String</span>::from(&amp;user.email[..]), <span class="comment">// !!! 还有这一句</span></span><br><span class="line">        ..user</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, user.username);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, user);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, user2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码，在创建 user2 时，String类型的字段，我们通过切片，创建了新的 String 数据，所以没有导致 <code>所有权</code> 转移。</p><h2 id="元祖结构体"><a href="#元祖结构体" class="headerlink" title="元祖结构体"></a>元祖结构体</h2><p>有一种结构体，没有具体的字段名，只有类型，这种结构体，称为 <code>元祖结构体 (tuple structs)</code>。看下面的代码</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Color</span></span>(<span class="built_in">i32</span>, <span class="built_in">i32</span>, <span class="built_in">i32</span>, <span class="built_in">i32</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> bg_color = Color(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, bg_color);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通过所引，访问结构体里的某个元素，与 元祖 的访问方式一样</span></span><br><span class="line">    <span class="keyword">let</span> r = bg_color.<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> g = bg_color.<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> b = bg_color.<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">let</span> a = bg_color.<span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一节聊了一下结构体的基本知识，下一节将聊一下更多关于结构体的东西。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;结构体可以用于组织不同类型的数据，和一些面向对像语言中的 &lt;code&gt;类&lt;/code&gt; 是很像的。&lt;/p&gt;
&lt;p&gt;这篇博客包含以下内容&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;结构体的定义&lt;/li&gt;
&lt;li&gt;通过一个函数，创建并返回一个结构体&lt;/li&gt;
&lt;li&gt;定义一个结构体，但数据来自
      
    
    </summary>
    
      <category term="Rust 基础学习" scheme="https://solleter.me/categories/Rust-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Rust" scheme="https://solleter.me/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>Rust基础学习-08-关于切片</title>
    <link href="https://solleter.me/2019/09/14/Rust%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0-08-%E5%85%B3%E4%BA%8E%E5%88%87%E7%89%87/"/>
    <id>https://solleter.me/2019/09/14/Rust基础学习-08-关于切片/</id>
    <published>2019-09-14T07:13:52.000Z</published>
    <updated>2019-09-14T08:03:45.651Z</updated>
    
    <content type="html"><![CDATA[<p>这篇博客有以下内容</p><ul><li><p>字符串切片解释</p></li><li><p>通用切片</p></li><li><p><code>String</code>，<code>&amp;String</code>，<code>&amp;str</code> 的区别</p><a id="more"></a></li></ul><blockquote><p>注意: <code>&amp;str 就是字符串切片</code></p></blockquote><h2 id="字符串切片"><a href="#字符串切片" class="headerlink" title="字符串切片"></a>字符串切片</h2><p>字符串切片可以理解为一个指向字符串部分数据的不可变的引用（指针）</p><p>看下面的代码</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="comment">// 这是一个 String</span></span><br><span class="line">    <span class="keyword">let</span> welcome = <span class="built_in">String</span>::from(<span class="string">"Hello, Rust"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这是一个字符串引用，&amp;String</span></span><br><span class="line">    <span class="keyword">let</span> rs = &amp;welcome;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这是一个切片，welcome的部分引用，</span></span><br><span class="line">    <span class="comment">// 从第0个字符，到第5个字符，但是不包含第5个字符</span></span><br><span class="line">    <span class="keyword">let</span> s1 = &amp;welcome[<span class="number">0</span>..<span class="number">5</span>];</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"s1: &#123;&#125;"</span>, s1); <span class="comment">// Hello</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个切片，从第0个字符，到第5个字符，包含第5个字符</span></span><br><span class="line">    <span class="keyword">let</span> s2 = &amp;welcome[<span class="number">0</span>..=<span class="number">5</span>];</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"s2: &#123;&#125;"</span>, s2); <span class="comment">// Hello,</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 与 [0..5]是一样的，同样也可以 [0..=5]包含第5个字符</span></span><br><span class="line">    <span class="keyword">let</span> s3 = &amp;welcome[..<span class="number">5</span>]; <span class="comment">// Hello</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果省略最后一个字符，则直接截取到字符串最后</span></span><br><span class="line">    <span class="keyword">let</span> s4 = &amp;welcome[<span class="number">0</span>..]; <span class="comment">// Hello, Rust</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 整个字符串的切片</span></span><br><span class="line">    <span class="keyword">let</span> s5 = &amp;welcome[..]; <span class="comment">// Hello, Rust</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"s3: &#123;&#125;\ns4: &#123;&#125;\ns5: &#123;&#125;"</span>, s3, s4, s5);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这也是一个切片</span></span><br><span class="line">    <span class="keyword">let</span> s3 = <span class="string">"Jack"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码每一行都有解释，输出如下</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s1: Hello</span><br><span class="line">s2: Hello,</span><br><span class="line">s3: Hello</span><br><span class="line">s4: Hello, Rust</span><br><span class="line">s5: Hello, Rust</span><br></pre></td></tr></table></figure><h2 id="通用切片"><a href="#通用切片" class="headerlink" title="通用切片"></a>通用切片</h2><p>切片不光可以用与字符串，还可以用于数组，看下面的代码</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span> ,<span class="number">3</span> ,<span class="number">4</span> ,<span class="number">5</span>];</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, &amp;a[<span class="number">0</span>..<span class="number">2</span>]);<span class="comment">// 输出 [1,2]</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, &amp;a[<span class="number">0</span>..=<span class="number">2</span>]);  <span class="comment">// 输出 [1,2,3]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="String-amp-String-amp-str-的区别"><a href="#String-amp-String-amp-str-的区别" class="headerlink" title="String, &amp;String, &amp;str 的区别"></a>String, &amp;String, &amp;str 的区别</h2><ul><li><code>String</code> 是一个可变的字符串结构</li><li><code>&amp;String</code> 是一个完整的字符串的引用</li><li><code>&amp;str</code> 是一个字符串切片，一个不可变的，字符串的部分引用</li></ul><p>平时使用的 <code>String::from</code> 其实就是通过一个字符串切片，创建一个可变字符串结构，看下面的代码</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> str1 = <span class="built_in">String</span>::from(<span class="string">"Hello, Rust"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> s1 = <span class="string">"Hello, Rust"</span>;</span><br><span class="line">    <span class="keyword">let</span> str2 = <span class="built_in">String</span>::from(s1);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"str1: &#123;&#125;\nstr2: &#123;&#125;"</span>, str1, str2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码，<code>str1</code> 和 <code>str2</code> 的内容是一样的。</p><h2 id="amp-String-和-amp-str-作为函数参数的区别"><a href="#amp-String-和-amp-str-作为函数参数的区别" class="headerlink" title="&amp;String 和 &amp;str 作为函数参数的区别"></a>&amp;String 和 &amp;str 作为函数参数的区别</h2><p>看下面的代码</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> str1 = <span class="built_in">String</span>::from(<span class="string">"Hello, Rust"</span>);</span><br><span class="line">    func1(&amp;str1);</span><br><span class="line">    func2(&amp;<span class="keyword">mut</span> str1);</span><br><span class="line">    func3(&amp;str1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串不可变引用作为函数参数</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">func1</span></span>(s: &amp;<span class="built_in">String</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"s: &#123;&#125;"</span>, s);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"len: &#123;&#125; capacity: &#123;&#125;"</span>, s.len(), s.capacity());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串可变引用作为函数参数，这里改变了原字符串内容</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">func2</span></span>(s: &amp;<span class="keyword">mut</span> <span class="built_in">String</span>) &#123;</span><br><span class="line">    s.push_str(<span class="string">" haha"</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"changed: &#123;&#125;"</span>, s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不可变的字符串切片作为函数参数，字符串切片没有 capacity() 函数</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">func3</span></span>(s: &amp;<span class="built_in">str</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"slice :&#123;&#125;"</span>, s);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"len: &#123;&#125;"</span>, s.len());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里要解释的一点是，作为函数参数，如果字符串切片 <code>&amp;str</code> 能满足要求，则推荐使用字符串切片，而不是整个字符串的引用。第5行代码调用func3的时候，传递的是整个字符串的引用，可以理解为&amp;String 和 &amp;str是可以互相转换的。</p><ul><li><p>字符串切片 <code>&amp;str</code> 是不可变的</p></li><li><p>如果函数只读使用字符串，则推荐使用字符串切片 <code>&amp;str</code> 作为函数参数</p></li><li>字符串切片有 <code>len()</code> 函数，但是没有 <code>capacity()</code> 函数</li><li>字符串引用 <code>&amp;String</code> 有 <code>len()</code> 和 <code>capacity()</code> 函数</li><li>如果要改变字符串，或者读取字符串的长度，则使用字符串引用 <code>&amp;String</code> 作为参数</li><li>如果要获取字符串的所有权，则使用 <code>String</code> 作为参数。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇博客有以下内容&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;字符串切片解释&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;通用切片&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;String&lt;/code&gt;，&lt;code&gt;&amp;amp;String&lt;/code&gt;，&lt;code&gt;&amp;amp;str&lt;/code&gt; 的区别&lt;/p&gt;
    
    </summary>
    
      <category term="Rust 基础学习" scheme="https://solleter.me/categories/Rust-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Rust" scheme="https://solleter.me/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>Rust基础学习-07-通俗解释引用与借用</title>
    <link href="https://solleter.me/2019/09/14/Rust%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0-07-%E5%BC%95%E7%94%A8%E4%B8%8E%E5%80%9F%E7%94%A8%E7%9A%84%E8%A7%A3%E9%87%8A/"/>
    <id>https://solleter.me/2019/09/14/Rust基础学习-07-引用与借用的解释/</id>
    <published>2019-09-14T05:56:30.000Z</published>
    <updated>2019-09-14T06:34:24.283Z</updated>
    
    <content type="html"><![CDATA[<p>今天我们来学习一下Rust中的引用与借用。我在看官方教程讲解引用与借用的时候，很困惑，分不清引用与借用。在第二遍理解的时候，大概能够理清了。</p><p>先来解释一下 <code>引用</code>，Rust官方文档中的解释是 <code>允许使用值但不获取其所有权</code>。与其他语言基本一样，可以理解为就是一个数据指针。</p><p>再来说一下 <code>借用</code>，官方文档中解释借用是指 <code>将获取引用作为函数参数称为 借用（borrowing）</code>。我的理解是，<code>借用</code>不是一个具体的东西，而是一种行为，对于Rust来说，当我们定义一下函数，而函数的形参是一个引用，或者说是一个指针时，这种行为，就叫做借用。可能不太精确地解释，可以理解为，当我们调用这个函数时，这个函数借用了外面某个数据的访问权限，但是并不拥有外面数据的所有权。就像生活中你借了某人的一个网站账号，这时，你可以访问网站上的内容了，但是你没有这个账号的所有权。</p><blockquote><p>当将引用作为参数时，也分为 <code>可变引用</code> 和 <code>不可变引用</code></p></blockquote><h2 id="不可变引用"><a href="#不可变引用" class="headerlink" title="不可变引用"></a>不可变引用</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> <span class="built_in">str</span> = <span class="built_in">String</span>::from(<span class="string">"Hello"</span>);</span><br><span class="line">    borrowing(&amp;<span class="built_in">str</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">borrowing</span></span>(<span class="built_in">str</span>: &amp;<span class="built_in">String</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Borrowing Str: &#123;&#125;"</span>, <span class="built_in">str</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="可变引用"><a href="#可变引用" class="headerlink" title="可变引用"></a>可变引用</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> <span class="built_in">str</span> = <span class="built_in">String</span>::from(<span class="string">"Hello"</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Source Str: &#123;&#125;"</span>, <span class="built_in">str</span>);<span class="comment">// 这里打印出原来的字符串</span></span><br><span class="line">    mut_borrowing(&amp;<span class="keyword">mut</span> <span class="built_in">str</span>);<span class="comment">// 调用后，字符串被改变</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Str: &#123;&#125;"</span>, <span class="built_in">str</span>); <span class="comment">// 打印改变后的字符串</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">mut_borrowing</span></span>(<span class="built_in">str</span>: &amp;<span class="keyword">mut</span> <span class="built_in">String</span>) &#123;</span><br><span class="line">    <span class="built_in">str</span>.push_str(<span class="string">" , Rust"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>有一条很重要的规则要记住，在同一作用域中，一个数据，有且只有一个 <code>可变</code> 引用。</p></blockquote><p>下面一段代码就是错的，编译不过，因为同一作用域下，同一个数据有多个可变引用</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> <span class="built_in">str</span> = <span class="built_in">String</span>::from(<span class="string">"Hello"</span>);</span><br><span class="line">    <span class="keyword">let</span> r1 = &amp;<span class="keyword">mut</span> <span class="built_in">str</span>;</span><br><span class="line">    <span class="keyword">let</span> r2 = &amp;<span class="keyword">mut</span> <span class="built_in">str</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;, &#123;&#125;"</span>, r1, r2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="关于数据竞争"><a href="#关于数据竞争" class="headerlink" title="关于数据竞争"></a>关于数据竞争</h2><p>Rust 这样的限制可以避免<code>数据竞争</code>，数据竞争可能由下面三个原因引起</p><ul><li>两个或更多指针同时访问同一数据。</li><li>至少有一个指针被用来写入数据。</li><li>没有同步数据访问的机制。</li></ul><h2 id="悬垂引用（Dangling-References）"><a href="#悬垂引用（Dangling-References）" class="headerlink" title="悬垂引用（Dangling References）"></a>悬垂引用（Dangling References）</h2><p>在拥有指针的编程语言中很容易出现一种情况，一个指针还存在，但是指针指向的内存已经被释放。在Rust中，这种为<code>悬垂引用</code>。在Rust中，Rust编译器确保指针永远不会变为悬垂状态。</p><p>看下面的代码，编译会出错</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> s = dangling();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个函数返回了字符串的引用，但是当这个函数结束时，字符串内存会被释放，&amp;s变为悬垂状态，所以编译出错</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">dangling</span></span>() -&gt; &amp;<span class="built_in">String</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> s = <span class="built_in">String</span>::from(<span class="string">"Hello rust"</span>);</span><br><span class="line">    &amp;s </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="引用的规则"><a href="#引用的规则" class="headerlink" title="引用的规则"></a>引用的规则</h2><ul><li>在任意给定时间，<strong>要么</strong> 只能有一个可变引用，<strong>要么</strong> 只能有多个不可变引用。</li><li>引用必须总是有效。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天我们来学习一下Rust中的引用与借用。我在看官方教程讲解引用与借用的时候，很困惑，分不清引用与借用。在第二遍理解的时候，大概能够理清了。&lt;/p&gt;
&lt;p&gt;先来解释一下 &lt;code&gt;引用&lt;/code&gt;，Rust官方文档中的解释是 &lt;code&gt;允许使用值但不获取其所有权&lt;/c
      
    
    </summary>
    
      <category term="Rust 基础学习" scheme="https://solleter.me/categories/Rust-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Rust" scheme="https://solleter.me/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>Rust基础学习-06-所有权、作用域</title>
    <link href="https://solleter.me/2019/09/11/Rust%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0-06-%E6%89%80%E6%9C%89%E6%9D%83%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    <id>https://solleter.me/2019/09/11/Rust基础学习-06-所有权、作用域/</id>
    <published>2019-09-11T02:13:33.000Z</published>
    <updated>2019-09-11T13:47:50.125Z</updated>
    
    <content type="html"><![CDATA[<p>本篇博客我们来解释几个名词，<strong><code>栈</code></strong>、<strong><code>堆</code></strong>、<strong><code>作用域</code></strong>、<strong><code>所有权</code></strong>、<strong><code>所有权移动</code></strong></p><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>栈是在代码运行时，可供使用的一块内存。它的存取数据方式是<code>先进后出</code>，或者说<code>后进先出</code>。想象有一个箱子，你往里放本子，最先放入的本子，是在箱子底下，当你要使用本子时，总是从顶上取一个使用，也就是取最后放入的一个本子。<br><strong>因为这种存取数据时总是在栈顶操作，而不需要去内存中寻找一个位置，所以栈的操作是时分迅速的。</strong><br>还有一个点是，存在栈里的数据，都是以知的固定大小。这一点的意思是，<em>例如要让用户输入一个名字，因为不知道用户会输入多少字符，所以这个数据就无法放在栈中，因为无法事先知道明确的大小。</em></p><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>在编译时大小未知或大小可能变化的数据，要改为存储在堆上。堆是缺乏组织的：当向堆放入数据时，你要请求一定大小的空间。操作系统在堆的某处找到一块足够大的空位，把它标记为已使用，并返回一个表示该位置地址的 <code>指针（pointer）</code>。这个过程称作 在堆上分配内存<code>（allocating on the heap）</code>，有时简称为 <code>分配（allocating）</code>。</p><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>作用域可以理解为一个东西在程序中的有效范围。对于Rust来说，当一个变量出了作用域后，对应的内存就会自动被释放掉，变量变为无效状态。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;                      <span class="comment">// s 在这里无效, 它尚未声明</span></span><br><span class="line">    <span class="keyword">let</span> s = <span class="string">"hello"</span>;   <span class="comment">// 从此处起，s 是有效的</span></span><br><span class="line">    <span class="comment">// 使用 s</span></span><br><span class="line">&#125;                      <span class="comment">// 此作用域已结束，s 不再有效</span></span><br></pre></td></tr></table></figure></p><h2 id="字符串类型-String"><a href="#字符串类型-String" class="headerlink" title="字符串类型 String"></a>字符串类型 String</h2><p>之前在数据类型一节，没有讲到 String，是因为牵扯到堆栈的问题，所以放在这里讲。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="comment">// 像这种直接硬编码在代码里的字符串，是放在栈上的，并且不可改变</span></span><br><span class="line">    <span class="keyword">let</span> name = <span class="string">"Jack"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用String::from创建的，是在堆上分配内存，并且是可以改变的</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> my_name = <span class="built_in">String</span>::from(<span class="string">"Jack"</span>);</span><br><span class="line">    my_name.push_str(<span class="string">", My name is Jack"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出 Jack, My name is Jack</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, my_name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>当调用 <code>String::from</code> 时，它的实现 (implementation) 请求其所需的内存。这在编程语言中是非常通用的。</p></blockquote><h2 id="所有权"><a href="#所有权" class="headerlink" title="所有权"></a>所有权</h2><ol><li>Rust 中每一个值都有一个被称为<strong><code>所有者</code></strong>的变量</li><li>值，有且只有一个所有者</li><li>当所有者（变量）离开作用域时，这个值被丢弃，内存被释放</li></ol><h2 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h2><p>先看下面一段代码<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">let</span> y = x;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"x: &#123;&#125;, y:&#123;&#125;"</span>, x, y);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> name1 = <span class="string">"Fred"</span>;</span><br><span class="line">    <span class="keyword">let</span> name2 = name1;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"name1: &#123;&#125;, name2: &#123;&#125;"</span>, name1, name2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>很正常，最后输出了 <code>x: 10, y:10</code> 和 <code>name1: Fred, name2: Fred</code></p><p>再看下面这段代码<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> name1 = <span class="built_in">String</span>::from(<span class="string">"Fred"</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"name1: &#123;&#125;"</span>, name1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> name2 = name1;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"name2: &#123;&#125;"</span>, name2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编译出错，这句会出错</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"name1 again: &#123;&#125;"</span>, name1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>为什么加了最后一句会编译出错呢，这里涉及到一个概念，<code>移动</code>。首先 name1 指向的值是分配在堆上的。当将 name1 赋值 给 name2后，在有一些编程语言，两个变量会指向同一块堆内存区域，但是对于Rust来说，不是这样的，Rust在这里会直接让 name1 <code>失效</code>，避免两个指针指向同一块堆内存。因为 Rust 会自动释放内存，这样可以避免当两个变量超出作用域时，导致重复的内存释放问题。将 name1 赋值给 name2，这个操作叫做<code>移动</code>，name1移动到了name2，移动后，name1自动失效，所以最后一句访问 name1 会编译出错。</p><p>更详细的内容 <a href="https://kaisery.github.io/trpl-zh-cn/ch04-01-what-is-ownership.html" target="_blank" rel="noopener">官方文档</a></p><blockquote><p>这里要记住，对于那些固定大小的数据类型，<code>i32</code>, <code>f32</code>, <code>bool</code>，<code>char</code> 等不会存在<code>移动</code>的问题。但是对于存储在<code>堆</code>上的数据，不管是String还是后面自定义的数据类型，这样的操作都会触发<code>移动</code></p></blockquote><h4 id="有没有办法将指上堆内存的变量赋值给另一个变量不触发移动呢？有！方法就是克隆，看下面的代码。"><a href="#有没有办法将指上堆内存的变量赋值给另一个变量不触发移动呢？有！方法就是克隆，看下面的代码。" class="headerlink" title="有没有办法将指上堆内存的变量赋值给另一个变量不触发移动呢？有！方法就是克隆，看下面的代码。"></a>有没有办法将指上堆内存的变量赋值给另一个变量不触发<code>移动</code>呢？有！方法就是克隆，看下面的代码。</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> name1 = <span class="built_in">String</span>::from(<span class="string">"Fred"</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"name1: &#123;&#125;"</span>, name1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> name2 = name1.clone();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"name2: &#123;&#125;"</span>, name2);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"name1 again: &#123;&#125;"</span>, name1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和之前的代码只有第5行变了，当调用了 <code>clone()</code>函数后，会导致 name1 指向的堆上的内存复制一份。所以这里就没有<code>移动</code>。String内部实现了 <code>clone()</code>，当我们自定义数据结构时，如果要有克隆功能，需要自己实现 <code>clone()</code>方法。这个后面会讲到。</p><h2 id="移动与函数"><a href="#移动与函数" class="headerlink" title="移动与函数"></a>移动与函数</h2><p>说完了<code>移动</code>，就需要说一下移动和函数相关的东西。如果将一个值作为参数，去调用一个函数，如果这个值是在栈上，那么不会发生什么，但是如果这个值是分配在堆上，那么它会移动到函数内部。</p><p>看下面的代码（注意看代码的注释）<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> name1 = <span class="built_in">String</span>::from(<span class="string">"Fred"</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"name1: &#123;&#125;"</span>, name1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// name1 的值移动了函数里</span></span><br><span class="line">    takes_ownership((name1));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// name1 已经无效，这里再使用就会编译出错</span></span><br><span class="line">    <span class="comment">// println!("name1 again: &#123;&#125;", name1);</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">takes_ownership</span></span>(<span class="built_in">str</span>: <span class="built_in">String</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"i have ownership: &#123;&#125;"</span>, <span class="built_in">str</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面的代码，函数在结束时将 <code>所有权</code> 返回<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> name1 = <span class="built_in">String</span>::from(<span class="string">"Fred"</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"name1: &#123;&#125;"</span>, name1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为name1不是mut的，所以这里的name1相当于创建了一个</span></span><br><span class="line">    <span class="comment">// 新的变量name1, 本质上并不是之前的</span></span><br><span class="line">    <span class="keyword">let</span> name1 = takes_and_gives_back(name1);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"name1 again: &#123;&#125;"</span>, name1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">takes_and_gives_back</span></span>(<span class="built_in">str</span>: <span class="built_in">String</span>) -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"i have ownership: &#123;&#125;"</span>, <span class="built_in">str</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这里将值返回，所有权移出函数</span></span><br><span class="line">    <span class="built_in">str</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="使用函数时每次都要转移所有权很繁琐，所下一节将介绍引用，不用每次将所有权转来转去"><a href="#使用函数时每次都要转移所有权很繁琐，所下一节将介绍引用，不用每次将所有权转来转去" class="headerlink" title="使用函数时每次都要转移所有权很繁琐，所下一节将介绍引用，不用每次将所有权转来转去"></a>使用函数时每次都要转移所有权很繁琐，所下一节将介绍<code>引用</code>，不用每次将所有权转来转去</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本篇博客我们来解释几个名词，&lt;strong&gt;&lt;code&gt;栈&lt;/code&gt;&lt;/strong&gt;、&lt;strong&gt;&lt;code&gt;堆&lt;/code&gt;&lt;/strong&gt;、&lt;strong&gt;&lt;code&gt;作用域&lt;/code&gt;&lt;/strong&gt;、&lt;strong&gt;&lt;code&gt;所有权&lt;/code&gt;&lt;
      
    
    </summary>
    
      <category term="Rust 基础学习" scheme="https://solleter.me/categories/Rust-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Rust" scheme="https://solleter.me/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>Rust基础学习-05-if、loop、while、for</title>
    <link href="https://solleter.me/2019/09/08/Rust%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0-05-if%E3%80%81loop%E3%80%81while%E3%80%81for/"/>
    <id>https://solleter.me/2019/09/08/Rust基础学习-05-if、loop、while、for/</id>
    <published>2019-09-08T13:52:27.000Z</published>
    <updated>2019-09-11T13:47:50.124Z</updated>
    
    <content type="html"><![CDATA[<p>这一篇博客来写一下基本的分支和循环，<code>if</code>、<code>else if</code>、<code>loop</code>、<code>while</code>、<code>for</code></p><h2 id="if-else"><a href="#if-else" class="headerlink" title="if else"></a>if else</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span> x &gt; <span class="number">100</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"x &gt; 100"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> x &gt; <span class="number">50</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"x &gt; 50"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"x &lt;= 50"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 还可以这样写</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> condition = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="keyword">if</span> condition &#123;</span><br><span class="line">        <span class="number">5</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="number">6</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="loop"><a href="#loop" class="headerlink" title="loop"></a>loop</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这段代码中，break counter * 100; 这一句是将和跳出循环，并把 counter * 100 返回</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="keyword">loop</span> &#123;</span><br><span class="line">        counter += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> counter == <span class="number">10</span> &#123;</span><br><span class="line">            <span class="keyword">break</span> counter * <span class="number">100</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"x: &#123;&#125;"</span>, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="while"><a href="#while" class="headerlink" title="while"></a>while</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> counter = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">while</span> counter &gt;= <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"counter: &#123;&#125;"</span>, counter);</span><br><span class="line">        counter -= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="for"><a href="#for" class="headerlink" title="for"></a>for</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这段代码将输出，0 到 9</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span>(<span class="number">0</span>..<span class="number">10</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"x: &#123;&#125;"</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 for 循环来遍历集合中的元素</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> nums = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">20</span>];</span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums.iter() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"num: &#123;&#125;"</span>, num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这一篇博客来写一下基本的分支和循环，&lt;code&gt;if&lt;/code&gt;、&lt;code&gt;else if&lt;/code&gt;、&lt;code&gt;loop&lt;/code&gt;、&lt;code&gt;while&lt;/code&gt;、&lt;code&gt;for&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;if-else&quot;&gt;&lt;a href
      
    
    </summary>
    
      <category term="Rust 基础学习" scheme="https://solleter.me/categories/Rust-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Rust" scheme="https://solleter.me/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>Rust基础学习-04-函数和表达式</title>
    <link href="https://solleter.me/2019/09/08/Rust%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0-04-%E5%87%BD%E6%95%B0%E5%92%8C%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>https://solleter.me/2019/09/08/Rust基础学习-04-函数和表达式/</id>
    <published>2019-09-08T13:27:01.000Z</published>
    <updated>2019-09-11T13:47:50.124Z</updated>
    
    <content type="html"><![CDATA[<h2 id="函数的定义"><a href="#函数的定义" class="headerlink" title="函数的定义"></a>函数的定义</h2><p>Rust 函数的定义是以 <code>fn</code> 开头，<code>main</code> 函数是Rust程序的入口函数<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="comment">// main 函数是Rust程序的入口点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个普通的函数</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">func1</span></span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"hello"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个带有返回值的函数，返回类型是 i32</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">func2</span></span>() -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">return</span> x + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个带参数的函数</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">func3</span></span>(x: <span class="built_in">i32</span>, y: <span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h2><blockquote><p><code>语句</code>，是执行一些操作，但不返回值的指令。<br><code>表达式</code>，计算并产生一个值</p></blockquote><p>这一点与其他语言不同，看下面的代码</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> value = &#123;</span><br><span class="line">    <span class="keyword">let</span> v1 = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">let</span> v2 = <span class="number">200</span>;</span><br><span class="line">    v1 + v2</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面是一个代码块，在代码块里定义了两个变量，注意看最后一句代码，执行了 <code>v1 + v2</code>，但是这一句结尾没有 <code>;</code>，这就是一个表达式，这个代码块执行了计算，并返回了一个值，这个值就是 <code>v1 + v2</code>。</p><p>再来看一个例子<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">sum</span></span>(x: <span class="built_in">i32</span>, y: <span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">    x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面这个函数计算了两个数的和，在以前，函数返回值我们会用 <code>return x + y</code>，但是现在，我们也可以不用 <code>return</code>，直接将 <code>x + y</code> 放在函数最后，作为函数的返回值。</p><blockquote><p>重点要注意的是，表达式结尾不要加<code>分号</code></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;函数的定义&quot;&gt;&lt;a href=&quot;#函数的定义&quot; class=&quot;headerlink&quot; title=&quot;函数的定义&quot;&gt;&lt;/a&gt;函数的定义&lt;/h2&gt;&lt;p&gt;Rust 函数的定义是以 &lt;code&gt;fn&lt;/code&gt; 开头，&lt;code&gt;main&lt;/code&gt; 函数是Rust程
      
    
    </summary>
    
      <category term="Rust 基础学习" scheme="https://solleter.me/categories/Rust-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Rust" scheme="https://solleter.me/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>Rust基础学习-03-变量常量和基本数据类型</title>
    <link href="https://solleter.me/2019/09/01/Rust%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0-03-%E5%8F%98%E9%87%8F%E5%B8%B8%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>https://solleter.me/2019/09/01/Rust基础学习-03-变量常量和基本数据类型/</id>
    <published>2019-09-01T06:41:39.000Z</published>
    <updated>2019-09-11T13:47:50.123Z</updated>
    
    <content type="html"><![CDATA[<p>这里来聊一下Rust的变量声明，以及基本的数据类型。</p><h2 id="可变性"><a href="#可变性" class="headerlink" title="可变性"></a>可变性</h2><p>与其他编程语言很不同的一点是，Rust 的变量默认是不可变的。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">5</span>;</span><br><span class="line">x = <span class="number">6</span>;</span><br></pre></td></tr></table></figure></p><blockquote><p>这一步编译会报错，因为rust的变量默认是不可变的。</p></blockquote><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> x = <span class="number">5</span>;</span><br><span class="line">x = <span class="number">6</span>;</span><br></pre></td></tr></table></figure><blockquote><p>在变量前加上 mut 则表示正在定义一个可变变量，再改其值，就不会报错。</p></blockquote><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> x = <span class="number">6</span>; </span><br><span class="line"><span class="keyword">let</span> x = <span class="string">"name"</span>;</span><br></pre></td></tr></table></figure><blockquote><p>1.定义一个变量，并将5这个值绑定给这个变量<br>2.重新使用 <code>let x</code> 定义一个变量，相当于定义了一个新的变量，并且将6绑定给这个变量<br>3.再次使用 <code>let x</code> 定义一个变量，并且绑定一个不同类型的值<br>上面的三行代码不会报错，在Rust中，这个操作叫做 <code>Shadowing</code>，中文翻译是，旧的变量被新的变量隐藏了。</p></blockquote><p><strong><code>mut</code> 与 <code>Shadowing</code> 的一个区别就是，<code>Shadowing</code> 相当于创建了一个新的变量，所以可以使用完全不同类型的值</strong></p><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><ol><li>声明常量使用 <code>const</code>，不使用 <code>let</code>，例如 <code>const MAX_NUM:u32 = 10000;</code>。</li><li>常量也<code>不能</code>使用 <code>mut</code>。</li><li>常量必须明确数据类型 const <code>MAX_NUM:u32</code> = 10000;</li><li>常量默认<code>不可变</code>，总是<code>不可变</code></li><li>常量命名规范是<code>大写字母加下划线</code></li></ol><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><h4 id="1-整型"><a href="#1-整型" class="headerlink" title="1. 整型"></a>1. 整型</h4><table><thead><tr><th style="text-align:center">长度</th><th style="text-align:center">有符号</th><th style="text-align:center">无符号</th></tr></thead><tbody><tr><td style="text-align:center">8-bit</td><td style="text-align:center"><code>i8</code></td><td style="text-align:center"><code>u8</code></td></tr><tr><td style="text-align:center">16-bit</td><td style="text-align:center"><code>i16</code></td><td style="text-align:center"><code>u16</code></td></tr><tr><td style="text-align:center">32-bit</td><td style="text-align:center"><code>i32</code></td><td style="text-align:center"><code>u32</code></td></tr><tr><td style="text-align:center">64-bit</td><td style="text-align:center"><code>i64</code></td><td style="text-align:center"><code>u64</code></td></tr><tr><td style="text-align:center">arch</td><td style="text-align:center"><code>isize</code></td><td style="text-align:center"><code>usize</code></td></tr></tbody></table><blockquote><ol><li>有符号可存储正值和负值，无符号只能存储正值</li><li>有符号的存储范围是 <strong>-(2<sup>n-1</sup>) ~ (2<sup>n-1</sup> - 1)</strong>，n是位数。例如i8可以存储的范围是 -128 ~  127</li><li>无符号的存储范围是 <strong>0 ~ (2<sup>n</sup> - 1)</strong>，例如 u8 可以存储的范围是 0 ~ 255</li><li><strong>isize</strong>和<strong>usize</strong>依赖于运行程序的计算机架构，64位架构上，它们就是64位，32位架构上，它们就是32位</li><li>默认类型是 <code>i32</code></li></ol></blockquote><h4 id="2-浮点型"><a href="#2-浮点型" class="headerlink" title="2. 浮点型"></a>2. 浮点型</h4><p>浮点型分为 <code>f32</code> 和 <code>f64</code>，默认类型是 <code>f64</code></p><h4 id="3-布尔型"><a href="#3-布尔型" class="headerlink" title="3. 布尔型"></a>3. 布尔型</h4><p>布尔型只有两个值 <code>true</code>，<code>false</code>。<code>let is_student: bool = false;</code></p><h4 id="4-字符型"><a href="#4-字符型" class="headerlink" title="4. 字符型"></a>4. 字符型</h4><p>字符型使用单引号，例如 <code>let c1: char = &#39;A&#39;;</code>， <code>let c1: char = &#39;ℤ&#39;;</code>。有一点要注意的是，<strong>Rust 的 char 类型代表了一个 Unicode 标量值（Unicode Scalar Value），这意味着它可以比 ASCII 表示更多内容。在 Rust 中，拼音字母（Accented letters），中文、日文、韩文等字符，emoji（绘文字）以及零长度的空白字符都是有效的 char 值。</strong></p><h4 id="5-数组类型"><a href="#5-数组类型" class="headerlink" title="5. 数组类型"></a>5. 数组类型</h4><p>每个元素的类型必须相同，数组的长度不能动态增长或缩小。如果要修改数组中的某个值，则数组定义时要加 <code>mut</code> 才行<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ,<span class="number">4</span> ,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> b: [<span class="built_in">i32</span>: <span class="number">10</span>] = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>];</span><br><span class="line"><span class="keyword">let</span> num1 = a[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">let</span> num2 = a[<span class="number">1</span>];</span><br></pre></td></tr></table></figure></p><h4 id="6-元祖类型"><a href="#6-元祖类型" class="headerlink" title="6. 元祖类型"></a>6. 元祖类型</h4><p>元祖类型是将多个相同或不同类型的值，组合起来。如果要修改元祖中的某个值，则元祖定义时要加<code>mut</code>才行。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> tup = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">"haha"</span>, <span class="string">'c'</span>, <span class="string">'B'</span>);</span><br><span class="line"><span class="keyword">let</span> tup2: (<span class="built_in">i32</span>, <span class="built_in">char</span>, <span class="built_in">char</span>) = (<span class="number">15</span>, <span class="string">'C'</span>, <span class="string">'D'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这一句称作解构元祖(destructuring), 将tup2中的值分给赋值给x,y,z</span></span><br><span class="line"><span class="keyword">let</span> (x, y z) = tup2;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问元祖中的某个值</span></span><br><span class="line"><span class="keyword">let</span> x = tup2.<span class="number">0</span>; <span class="comment">// 访问第0个值</span></span><br><span class="line"><span class="keyword">let</span> y = tup2.<span class="number">1</span>; <span class="comment">// 访问第1个值</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这里来聊一下Rust的变量声明，以及基本的数据类型。&lt;/p&gt;
&lt;h2 id=&quot;可变性&quot;&gt;&lt;a href=&quot;#可变性&quot; class=&quot;headerlink&quot; title=&quot;可变性&quot;&gt;&lt;/a&gt;可变性&lt;/h2&gt;&lt;p&gt;与其他编程语言很不同的一点是，Rust 的变量默认是不可变的。&lt;
      
    
    </summary>
    
      <category term="Rust 基础学习" scheme="https://solleter.me/categories/Rust-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Rust" scheme="https://solleter.me/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>Rust基础学习-02-创建及运行工程</title>
    <link href="https://solleter.me/2019/09/01/Rust%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0-02-%E5%88%9B%E5%BB%BA%E5%8F%8A%E8%BF%90%E8%A1%8C%E5%B7%A5%E7%A8%8B/"/>
    <id>https://solleter.me/2019/09/01/Rust基础学习-02-创建及运行工程/</id>
    <published>2019-09-01T04:57:35.000Z</published>
    <updated>2019-09-11T13:47:50.123Z</updated>
    
    <content type="html"><![CDATA[<p>这篇博客将介绍使用 <code>cargo</code> 来创建，测试，编译，运行工程。在使用 <code>cargo</code> 之前，我们先来说一下不用 cargo 的情况下，直接用 <code>rustc</code> 编译代码。</p><h2 id="使用-rustc-编译代码"><a href="#使用-rustc-编译代码" class="headerlink" title="使用 rustc 编译代码"></a>使用 <code>rustc</code> 编译代码</h2><p>首先我们新建一个文件 <code>hello.rs</code>，里面写上下面的代码<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"hello rust!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后在终端使用命令 <code>rustc hello.rs</code> 编译代码，之后可以看到在 hello.rs 所在目录生成了一个名为 <code>hello</code> 的可执行文件，运行 <code>hello</code> 这个可执行文件，将输出 <code>hello rust!</code> ，好了，你已经学会了使用 <code>rustc</code> 编译 rust 代码。</p><h2 id="使用-cargo"><a href="#使用-cargo" class="headerlink" title="使用 cargo"></a>使用 <code>cargo</code></h2><p><code>cargo</code> 是 rust 的构建系统和包管理器。使用 cargo 可以很方便的构建代码，下载依赖库，测试代码等。所以大多数情况，推荐使用 cargo 来构建项目。</p><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><ul><li><strong><code>cargo new first-project</code></strong><br>创建一个新项目，这里的项目名使用 first-project， 可以自定义<br><br></li><li><strong><code>cargo build</code></strong><br>构建项目，这个命令需要先 <code>cd first-project</code> 进入到项目目录下，然后再运行。运行后会生成项目的可执行文件。<br><br></li><li><strong><code>cargo run</code></strong><br>运行构建好的项目。也可以不用 <code>cargo build</code>， 直接 <code>cargo run</code>，cargo如果发现项目没有编译，或者有改变，将自动重新去build，然后自动运行。<br><br></li><li><strong><code>cargo build --release</code></strong><br>构建发布版本<br><br></li><li><strong><code>cargo run --release</code></strong><br>运行发布版本<br><br></li><li><strong><code>cargo check</code>，<code>cargo check --release</code></strong><br>这个是用来快速检查代码确保可以编译，但并不产生可执行文件。这个命令比<code>cargo build</code> 快的多。如果项目比较大，编译时间比较长，可以先用这个命令检查一个代码是否能够通过编译。</li></ul><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><ul><li><code>cargo build</code> 时，如果 cargo 发现已经 build 过，但是代码没有改变，将不会再次 build。</li><li>查看 <code>first-project</code> 会发现有几个自动生成的文件<ul><li><code>Cargo.toml</code> 这个是项目的配置文件，项目的一些依赖，也都配置在这里面，这个后面用到时再细说。</li><li><code>Cargo.lock</code> 这个是<code>cargo</code>用来记录项目依赖的实际版本，不要管就OK。</li><li><code>src</code>目录是代码目录，里面的 <code>main.rs</code> 是项目的入口。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这篇博客将介绍使用 &lt;code&gt;cargo&lt;/code&gt; 来创建，测试，编译，运行工程。在使用 &lt;code&gt;cargo&lt;/code&gt; 之前，我们先来说一下不用 cargo 的情况下，直接用 &lt;code&gt;rustc&lt;/code&gt; 编译代码。&lt;/p&gt;
&lt;h2 id=&quot;使用-ru
      
    
    </summary>
    
      <category term="Rust 基础学习" scheme="https://solleter.me/categories/Rust-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Rust" scheme="https://solleter.me/tags/Rust/"/>
    
  </entry>
  
</feed>
