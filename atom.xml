<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>F社</title>
  
  <subtitle>上你娘的班</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://solleter.me/"/>
  <updated>2019-10-07T14:25:05.510Z</updated>
  <id>https://solleter.me/</id>
  
  <author>
    <name>F君</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>统计学笔记01</title>
    <link href="https://solleter.me/2019/10/07/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E7%AC%94%E8%AE%B001/"/>
    <id>https://solleter.me/2019/10/07/统计学笔记01/</id>
    <published>2019-10-07T14:15:43.000Z</published>
    <updated>2019-10-07T14:25:05.510Z</updated>
    
    <content type="html"><![CDATA[<p>这一节笔记涉及到的概念有 <code>均值</code>，<code>中位数</code>，<code>众数</code>，<code>极差</code>，<code>中程数</code>，<code>总体均值</code>，<code>样本均值</code>，<code>离群值</code>。</p><h2 id="1-均值"><a href="#1-均值" class="headerlink" title="1. 均值"></a>1. 均值</h2><p>所有数之和除以数的个数</p><h2 id="2-中位数"><a href="#2-中位数" class="headerlink" title="2. 中位数"></a>2. 中位数</h2><p>所有数从小到大排序，中间的那个数。如果数的总数为偶数，则为中间两个数的平均数</p><h2 id="3-众数"><a href="#3-众数" class="headerlink" title="3. 众数"></a>3. 众数</h2><p>出现次数最多的那个数</p><h2 id="4-极差"><a href="#4-极差" class="headerlink" title="4. 极差"></a>4. 极差</h2><p>最大与最小数之和</p><h2 id="5-中程数"><a href="#5-中程数" class="headerlink" title="5. 中程数"></a>5. 中程数</h2><p>最大与最小数之和除以2</p><h2 id="6-总体均值"><a href="#6-总体均值" class="headerlink" title="6. 总体均值"></a>6. 总体均值</h2><p>总数数据的均值</p><h2 id="7-样本均值"><a href="#7-样本均值" class="headerlink" title="7. 样本均值"></a>7. 样本均值</h2><p>从总体数据中抽样出的部分数据，然后计算这部分数据的均值</p><h2 id="8-离群值"><a href="#8-离群值" class="headerlink" title="8. 离群值"></a>8. 离群值</h2><p>一组数据中，某些值明显与其他值相差很大，这种数据叫做离群值，例如 <code>3, 3, 3, 3, 3, 3, 100</code> 这一组数中，100明显与其他值相差很大，100就是离群值，如果这一组数计算算术平均数，则这个平均数无法反应数据的集中趋势。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这一节笔记涉及到的概念有 &lt;code&gt;均值&lt;/code&gt;，&lt;code&gt;中位数&lt;/code&gt;，&lt;code&gt;众数&lt;/code&gt;，&lt;code&gt;极差&lt;/code&gt;，&lt;code&gt;中程数&lt;/code&gt;，&lt;code&gt;总体均值&lt;/code&gt;，&lt;code&gt;样本均值&lt;/code&gt;，&lt;code&gt;
      
    
    </summary>
    
      <category term="统计学笔记" scheme="https://solleter.me/categories/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="统计学" scheme="https://solleter.me/tags/%E7%BB%9F%E8%AE%A1%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>使用外部工具登录Google VPS</title>
    <link href="https://solleter.me/2019/09/29/%E4%BD%BF%E7%94%A8%E5%A4%96%E9%83%A8%E5%B7%A5%E5%85%B7%E7%99%BB%E5%BD%95Google-VPS/"/>
    <id>https://solleter.me/2019/09/29/使用外部工具登录Google-VPS/</id>
    <published>2019-09-29T02:04:23.000Z</published>
    <updated>2019-10-07T13:48:22.231Z</updated>
    
    <content type="html"><![CDATA[<p>Google的VPS创建好后，默认是无法通过外部的工具ssh登录的，要使用外部SSH工具登录，需要修改ssh的配置。</p><ol><li><p>首先在VM实例页面，使用Google网页上的SSH进行登录</p><p><img src="https://i.loli.net/2019/09/29/rG5NiBKqHA3bTPg.png" alt="1.png"></p></li><li><p>登录后，执行命令 <code>sudo -i</code> 切换到 <code>root</code> 用户</p></li><li><p>使用 <code>passwd root</code> 命令，设置 <code>root</code> 用户登录密码</p></li><li><p>修改 <code>/etc/ssh/sshd_config</code> 文件，要修改的两行内容如下</p><blockquote><p>PermitRootLogin yes</p><p>PasswordAuthentication yes</p></blockquote></li><li><p>使用命令 <code>/etc/init.d/ssh restart</code> 重启ssh服务</p></li></ol><p>好了，现在就可以使用外部的ssh工具进行VPS的登录了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Google的VPS创建好后，默认是无法通过外部的工具ssh登录的，要使用外部SSH工具登录，需要修改ssh的配置。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;首先在VM实例页面，使用Google网页上的SSH进行登录&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.
      
    
    </summary>
    
      <category term="记录" scheme="https://solleter.me/categories/%E8%AE%B0%E5%BD%95/"/>
    
    
  </entry>
  
  <entry>
    <title>Rust基础学习-13-HashMap的基本应用</title>
    <link href="https://solleter.me/2019/09/26/Rust%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0-13-HashMap%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%BA%94%E7%94%A8/"/>
    <id>https://solleter.me/2019/09/26/Rust基础学习-13-HashMap的基本应用/</id>
    <published>2019-09-26T09:57:30.000Z</published>
    <updated>2019-10-07T13:48:22.230Z</updated>
    
    <content type="html"><![CDATA[<p><code>HashMap</code> 用于存储键值对，类似于其他编程语言中的字典。在标准库的定义是 <code>HashMap&lt;K, V&gt;</code> ，下面将用代码解释 <code>HashMap</code> 的基本使用。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="comment">// 先定义一个hashmap, 然后插入值</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> scores = HashMap::new();</span><br><span class="line">    scores.insert(<span class="number">1001</span>, <span class="number">100</span>);</span><br><span class="line">    scores.insert(<span class="number">1002</span>, <span class="number">200</span>);</span><br><span class="line">    scores.insert(<span class="number">1003</span>, <span class="number">300</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"原始map: &#123;:?&#125;"</span>, scores);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否存在某个Key</span></span><br><span class="line">    <span class="keyword">let</span> has1001 = scores.contains_key(&amp;<span class="number">1001</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"是否有key 1001: &#123;&#125;"</span>, has1001);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除一个值，参数是key的引用</span></span><br><span class="line">    scores.remove(&amp;<span class="number">1001</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"移除 1001 后: &#123;:?&#125;"</span>, scores);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入一个已经存在的值将覆盖原有值</span></span><br><span class="line">    scores.insert(<span class="number">1002</span>, <span class="number">101</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"覆盖 1002的值: &#123;:?&#125;"</span>, scores);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果一个键不存在，则插入新的键值对，如果存在，则什么也不做</span></span><br><span class="line">    scores.entry(<span class="number">1002</span>).or_insert(<span class="number">500</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"如果 1002 不存在，则插入key 1002, value 500: &#123;:?&#125;"</span>, scores);</span><br><span class="line"></span><br><span class="line">    scores.entry(<span class="number">1004</span>).or_insert(<span class="number">700</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"如果 1004 不存在，则插入key 1004, value 700: &#123;:?&#125;"</span>, scores);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取一个键的值，如果存在，返回类型是枚举 Option&lt;T&gt;</span></span><br><span class="line">    <span class="comment">// 如果有值，则返回值Some(T)，没有则返回None</span></span><br><span class="line">    <span class="keyword">let</span> value_1004 = scores.get(&amp;<span class="number">1004</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"获取1004的value: &#123;:?&#125;"</span>, value_1004);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> value_2000 = scores.get(&amp;<span class="number">2000</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"获取2000的value: &#123;:?&#125;"</span>, value_2000);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先获取原始值，的引用，然后改变原始值</span></span><br><span class="line">    <span class="keyword">let</span> value_1003 = scores.entry(<span class="number">1003</span>).or_insert(<span class="number">0</span>);</span><br><span class="line">    *value_1003 += <span class="number">54</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"在原始1003的值的基础上，加上54: &#123;:?&#125;"</span>, scores);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码使用最基本的拷贝类型 <code>i32</code> 作为键和值解释了一个 <code>HashMap</code> 基本的方法应用，更详细的方法可以参考 <a href="https://doc.rust-lang.org/std/collections/struct.HashMap.html" target="_blank" rel="noopener">HashMap的文档</a></p><p>下面看一下以<code>String</code>类型作为 key 和 value 会怎么样</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> key = <span class="string">"Jack"</span>.to_string();</span><br><span class="line">    <span class="keyword">let</span> value = <span class="string">"上海市浦东新区"</span>.to_string();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> map:HashMap&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt; = HashMap::new();</span><br><span class="line">    map.insert(key, value);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"map: &#123;:?&#125;"</span>, map);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// println!("&#123;&#125; &#123;&#125;", key, value);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，看最后一句被注释掉的代码，如果去掉注释，将编译出错，因为我们定义的 <strong>key</strong> 和 <strong>value</strong> 是<code>String</code>类型的，在插入到 <strong>hashmap</strong> 后，<strong>key</strong> 和 <strong>value</strong> 的的所有权将移动到 <strong>hashmap</strong> 中，所以再访问就会出错。</p><p>上面第<strong>7</strong>行代码，定义一个 <code>HashMap</code> 时，我们给map变量指定了具体的<code>HashMap</code>类型，这里不指定也行，Rust会根据上下文自动推断中 <code>HashMap</code> 中存储的数据类型。</p><p><code>let mut map = HashMap::new();</code></p><p>这里只是简单地介绍了一下 <code>HashMap</code> 的一些应用，更复杂的使用将在后面的博客中详细介绍。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;HashMap&lt;/code&gt; 用于存储键值对，类似于其他编程语言中的字典。在标准库的定义是 &lt;code&gt;HashMap&amp;lt;K, V&amp;gt;&lt;/code&gt; ，下面将用代码解释 &lt;code&gt;HashMap&lt;/code&gt; 的基本使用。&lt;/p&gt;
&lt;figure cl
      
    
    </summary>
    
      <category term="Rust 基础学习" scheme="https://solleter.me/categories/Rust-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Rust" scheme="https://solleter.me/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>Rust基础学习-12-再聊一下String</title>
    <link href="https://solleter.me/2019/09/26/Rust%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0-12-%E5%86%8D%E8%81%8A%E4%B8%80%E4%B8%8BString/"/>
    <id>https://solleter.me/2019/09/26/Rust基础学习-12-再聊一下String/</id>
    <published>2019-09-26T02:14:56.000Z</published>
    <updated>2019-10-07T13:48:22.230Z</updated>
    
    <content type="html"><![CDATA[<p>之前我们已经使用过 <code>String</code>，对于 <code>String</code> 的解释是可增长的、可变的、有所有权的、UTF-8 编码的字符串类型。<code>String</code> 的数据是存在于堆上的。下面再看一些关于 <code>String</code> 的使用。</p><p><strong>1. 创建字符串</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="comment">// 创建一个字符串</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> s1 = <span class="built_in">String</span>::new();</span><br><span class="line">    s1.push_str(<span class="string">"Hello"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> s2 = <span class="built_in">String</span>::from(<span class="string">"Hello"</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> s3 = <span class="string">"Hello"</span>.to_string();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上面 s1，s2，s3分别创建了一个字符串，并填充内容 “Hello”，这三种方式都可以达到相同的目的。</p></blockquote><p><strong>2. 除上可以 <code>push_str</code> ，还可以 <code>push</code> 单个字符</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> s1 = <span class="built_in">String</span>::new();</span><br><span class="line">    s1.push(<span class="string">'H'</span>);</span><br><span class="line">    s1.push(<span class="string">'e'</span>);</span><br><span class="line">    s1.push(<span class="string">'l'</span>);</span><br><span class="line">    s1.push(<span class="string">'l'</span>);</span><br><span class="line">    s1.push(<span class="string">'o'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3.字符串的拼接</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> s1 = <span class="string">"Hello"</span>.to_string();</span><br><span class="line">    <span class="keyword">let</span> s2 = <span class="string">", Rust"</span>.to_string();</span><br><span class="line">    <span class="keyword">let</span> s3 = <span class="string">" Haha"</span>.to_string();</span><br><span class="line">    <span class="keyword">let</span> s4 = s1 + &amp;s2 + &amp;s3;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"s2: &#123;&#125;\ns3: &#123;&#125;\ns4: &#123;&#125;"</span>,  s2, s3, s4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意，如果要使用 <code>+</code> 去拼接字符串，会先获得第一个变量的所有权，然后附加上后面变量的内容拷贝。上面的代码，s4 创建后，s1将不再有效。</p></blockquote><p><strong>4. 使用 <code>format!</code> 宏拼接字符串</strong></p><p>在涉及到很多的字符串要拼接时，使用 <code>+</code> 就不那么方便，下面使用 <code>format!</code> 宏进行操作，就方便很多。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> s1 = <span class="string">"Hello"</span>.to_string();</span><br><span class="line">    <span class="keyword">let</span> s2 = <span class="string">", Rust"</span>.to_string();</span><br><span class="line">    <span class="keyword">let</span> s3 = <span class="string">" Haha"</span>.to_string();</span><br><span class="line">    <span class="keyword">let</span> s4 = <span class="built_in">format!</span>(<span class="string">"&#123;&#125;-&#123;&#125;-&#123;&#125;"</span>, s1, s2, s3);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"s1: &#123;&#125;\ns2: &#123;&#125;\ns3: &#123;&#125;\ns4: &#123;&#125;"</span>, s1, s2, s3, s4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>从上面可以看出，<code>format!</code> 宏在拼接字符串时，并不获取任何所有权</p></blockquote><p><strong>5. 获取字符串的长度</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> s1 = <span class="string">"Hello"</span>.to_string();</span><br><span class="line">    <span class="keyword">let</span> len = s1.len();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>6. 字符串的遍历</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> s1 = <span class="string">"Hello"</span>.to_string();</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">char</span> <span class="keyword">in</span> s1.chars()&#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, <span class="built_in">char</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>String</code> 不支持以 <code>[0]</code> 这样的索引形式访问单个字符，具体原因请看后面关于 <code>String</code> 的详细内容连接。但是 <code>String</code> 可以用上面的形式遍历每一个字符。</p></blockquote><p><strong>7. 字符串原始字节遍历</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">for</span> b <span class="keyword">in</span> <span class="string">"नमस्ते"</span>.bytes() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="上面只是讨论-String-很基本的使用，但是-String-并不简单，里面还有很多很多内容，具体到里面的一些原理和实现，请阅读下面的连接"><a href="#上面只是讨论-String-很基本的使用，但是-String-并不简单，里面还有很多很多内容，具体到里面的一些原理和实现，请阅读下面的连接" class="headerlink" title="上面只是讨论 String 很基本的使用，但是 String 并不简单，里面还有很多很多内容，具体到里面的一些原理和实现，请阅读下面的连接"></a>上面只是讨论 <code>String</code> 很基本的使用，但是 <code>String</code> 并不简单，里面还有很多很多内容，具体到里面的一些原理和实现，请阅读下面的连接</h4><p>Rust 程序语言设计 <a href="https://kaisery.github.io/trpl-zh-cn/ch08-02-strings.html" target="_blank" rel="noopener">https://kaisery.github.io/trpl-zh-cn/ch08-02-strings.html</a></p><p>String 官方文档 <a href="https://doc.rust-lang.org/std/string/struct.String.html" target="_blank" rel="noopener">https://doc.rust-lang.org/std/string/struct.String.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前我们已经使用过 &lt;code&gt;String&lt;/code&gt;，对于 &lt;code&gt;String&lt;/code&gt; 的解释是可增长的、可变的、有所有权的、UTF-8 编码的字符串类型。&lt;code&gt;String&lt;/code&gt; 的数据是存在于堆上的。下面再看一些关于 &lt;code&gt;Stri
      
    
    </summary>
    
      <category term="Rust 基础学习" scheme="https://solleter.me/categories/Rust-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Rust" scheme="https://solleter.me/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>Rust基础学习-12-vector的使用</title>
    <link href="https://solleter.me/2019/09/22/Rust%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0-12-vector%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://solleter.me/2019/09/22/Rust基础学习-12-vector的使用/</id>
    <published>2019-09-22T09:02:23.000Z</published>
    <updated>2019-09-22T09:54:45.576Z</updated>
    
    <content type="html"><![CDATA[<p>这一篇博客我们来聊一下Rust中 <strong>vector</strong> 的使用。<strong>vector</strong> 就像数组一样，用于存储同一类型的一系列的值，但是允许动态地添加和删除值，以及拥有一些其他的方法。</p><h2 id="vector-的定义"><a href="#vector-的定义" class="headerlink" title="vector 的定义"></a>vector 的定义</h2><p>在代码中，使用 <code>Vec&lt;T&gt;</code> 来定义一个 vector 类型的变量</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">  <span class="comment">// 这一个可以动态添加和删除元素</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> vec1: <span class="built_in">Vec</span>&lt;<span class="built_in">u32</span>&gt; = <span class="built_in">Vec</span>::new();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 在定义的时候就填充好值，因为没有mut，所以无法动态添加和删除</span></span><br><span class="line">  <span class="keyword">let</span> vec2 = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">  <span class="keyword">let</span> vec3 = <span class="built_in">vec!</span>[<span class="string">"str1"</span>, <span class="string">"str2"</span>, <span class="string">"str3"</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>vec!</code> 是rust提供的宏，可以动态地根据我们的数据，自动推断出这个 vector 变量的类型</p></blockquote><h2 id="添加和删除元素"><a href="#添加和删除元素" class="headerlink" title="添加和删除元素"></a>添加和删除元素</h2><p>向 <strong>vector</strong> 中添加元素，使用 <code>push</code> 方法，从vector中删除最后添加的元素，使用 <code>pop</code> 方法</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> nums: <span class="built_in">Vec</span>&lt;<span class="built_in">u32</span>&gt; = <span class="built_in">Vec</span>::new();</span><br><span class="line">    nums.push(<span class="number">10</span>);</span><br><span class="line">    nums.push(<span class="number">11</span>);</span><br><span class="line">    nums.push(<span class="number">12</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, nums); <span class="comment">// 打印出 [10, 11, 12]</span></span><br><span class="line">    nums.pop(); <span class="comment">// 将最后的元素拿出来丢了</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, nums); <span class="comment">// 这里打印出 [10, 11]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>pop</code> 会将值返回，返回的类型是 <code>Option&lt;T&gt;</code> 类型，我们可以定义一个变量接收 pop 出来的值</p></blockquote><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> nums: <span class="built_in">Vec</span>&lt;<span class="built_in">u32</span>&gt; = <span class="built_in">Vec</span>::new();</span><br><span class="line">    nums.push(<span class="number">10</span>);</span><br><span class="line">    nums.push(<span class="number">11</span>);</span><br><span class="line">    nums.push(<span class="number">12</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, nums);</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">let</span> x = nums.pop();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"x: &#123;:?&#125;"</span>, x);  <span class="comment">// 这里将打印出 Some(12)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果 vector 中已经没有元素，继续使用 <code>pop</code>，将返回 <code>Option&lt;T&gt;</code> 中的 <code>None</code></p></blockquote><h2 id="访问特定所以呢的元素"><a href="#访问特定所以呢的元素" class="headerlink" title="访问特定所以呢的元素"></a>访问特定所以呢的元素</h2><p>就像数组一样，vector也可以使用 <code>[index]</code> 这样的形式去访问某个元素，还可以使用 <code>get(index)</code> 方法访问。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> nums: <span class="built_in">Vec</span>&lt;<span class="built_in">u32</span>&gt; = <span class="built_in">Vec</span>::new();</span><br><span class="line">    nums.push(<span class="number">10</span>);</span><br><span class="line">    nums.push(<span class="number">11</span>);</span><br><span class="line">    nums.push(<span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里获取的是第0个元素的引用</span></span><br><span class="line">    <span class="keyword">let</span> first_num = &amp;nums[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"first_num: &#123;&#125;"</span>, first_num);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get 方法在这里返回的 Option&lt;&amp;u32&gt;</span></span><br><span class="line">    <span class="keyword">let</span> second_num = nums.get(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"x:&#123;:?&#125;"</span>, second_num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果我们尝试访问越界索引的元素会怎样呢？如果使用 <code>[index]</code> 这种形式，Rust 会直接导致 panic 然后退出进程，如果使用 <code>get(index)</code> 这种形式，Rust会返回 <code>Option&lt;T&gt;</code> 中的 <code>None</code></p></blockquote><p><strong>为什么这里获取值的时候，要获取它引用，而不是值本身呢？对于 copy 类型的数据，似乎没有什么区别，但是对于 String 这样类型的数据，如果我们直接获取值，就会导致所有权的移动。看下面的遍历代码</strong></p><h2 id="遍历-vector"><a href="#遍历-vector" class="headerlink" title="遍历 vector"></a>遍历 vector</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> names: <span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt; = <span class="built_in">Vec</span>::new();</span><br><span class="line">    names.push(<span class="string">"Jack"</span>.to_string());</span><br><span class="line">    names.push(<span class="string">"Tony"</span>.to_string());</span><br><span class="line">    names.push(<span class="string">"Tina"</span>.to_string());</span><br><span class="line">    <span class="comment">// 遍历vector中每一个元素，然后打印出来</span></span><br><span class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> &amp;names &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"name: &#123;&#125;"</span>, name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印出整个vector来</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"names: &#123;:?&#125;"</span>, names);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码，如果我们把第<code>7</code>行改为 <code>for name in names</code> 那么这段代码就会<code>编译不过</code>，因为 vector 中的值的所有权，已经移动到了 println 中的 name 变量，所以在第12行再次访问的时候，就会出错，所以编译器会直接编译不过。<strong>所以，在获取和遍历 vector 中值的时候，一定要注意所有权转移的问题</strong></p><h2 id="在-vector-中存储不同类型的值"><a href="#在-vector-中存储不同类型的值" class="headerlink" title="在 vector 中存储不同类型的值"></a>在 vector 中存储不同类型的值</h2><p>在博客开始的时候我们说 vector 只能存储相同类型的值，这是没错的。这里我们存储不同类型的值，是使用了上一篇讲到的枚举类型而做到的。看下面的代码</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Data</span></span> &#123;</span><br><span class="line">    IData(<span class="built_in">i32</span>),</span><br><span class="line">    FData(<span class="built_in">f32</span>),</span><br><span class="line">    SData(<span class="built_in">String</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> data_sets: <span class="built_in">Vec</span>&lt;Data&gt; = <span class="built_in">Vec</span>::new();</span><br><span class="line">    data_sets.push(Data::IData(<span class="number">10</span>));</span><br><span class="line">    data_sets.push(Data::FData(<span class="number">3.14159</span>));</span><br><span class="line">    data_sets.push(Data::SData(<span class="built_in">String</span>::from(<span class="string">"Hello Rust"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先定义一个拥有多种数据类型的枚举，然后定义一个存储这种枚举类型的 vector，这样就实现了一个 vector 中存储不同类型的数据。</p><p><a href="https://doc.rust-lang.org/std/vec/struct.Vec.html" target="_blank" rel="noopener">Vec详细使用时，可以参考源代码的文档</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这一篇博客我们来聊一下Rust中 &lt;strong&gt;vector&lt;/strong&gt; 的使用。&lt;strong&gt;vector&lt;/strong&gt; 就像数组一样，用于存储同一类型的一系列的值，但是允许动态地添加和删除值，以及拥有一些其他的方法。&lt;/p&gt;
&lt;h2 id=&quot;vector-
      
    
    </summary>
    
      <category term="Rust 基础学习" scheme="https://solleter.me/categories/Rust-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Rust" scheme="https://solleter.me/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>Rust基础学习-11-枚举的使用</title>
    <link href="https://solleter.me/2019/09/21/Rust%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0-11-%E6%9E%9A%E4%B8%BE%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://solleter.me/2019/09/21/Rust基础学习-11-枚举的使用/</id>
    <published>2019-09-21T05:51:19.000Z</published>
    <updated>2019-09-21T08:01:04.971Z</updated>
    
    <content type="html"><![CDATA[<p>枚举 <code>enum</code>，用于从众多选项中选择一个。 </p><h2 id="定义枚举"><a href="#定义枚举" class="headerlink" title="定义枚举"></a>定义枚举</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Week</span></span> &#123;</span><br><span class="line">    Monday,</span><br><span class="line">    Tuesday,</span><br><span class="line">    Wednesday,</span><br><span class="line">    Thursday,</span><br><span class="line">    Friday,</span><br><span class="line">    Saturday,</span><br><span class="line">    Sunday,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> today = Week::Saturday;  <span class="comment">// 使用枚举</span></span><br><span class="line">    <span class="keyword">let</span> tomorrow = Week::Sunday;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, today);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是我们在很多面向对象语言中常见的定义枚举的方式</p><blockquote><p>以往对枚举的认识，就是枚举限定了几个固定的选项，我们只能使用众多选项中的一个，或者说，只是使用了某一个元素的名字，例如上面Week枚举中的Monday，至于Monday是什么，无所谓，Monday = 1也好，Monday = 10也好，我们并不关心。但是对于Rust，我们对枚举有更进一步的应用。</p></blockquote><h2 id="用枚举代替结构体"><a href="#用枚举代替结构体" class="headerlink" title="用枚举代替结构体"></a>用枚举代替结构体</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">IpAddr</span></span> &#123;</span><br><span class="line">    V4(<span class="built_in">u8</span>, <span class="built_in">u8</span>, <span class="built_in">u8</span>, <span class="built_in">u8</span>), <span class="comment">// 这个枚举成员是四个u8类型的元祖</span></span><br><span class="line">    V6(<span class="built_in">String</span>), <span class="comment">// 这个枚举成员是String类型</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="comment">// 定义一个枚举变量，并将四个值存放</span></span><br><span class="line">    <span class="keyword">let</span> loopbackV4 = IpAddr::V4(<span class="number">127</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 定义另一个枚举变量，存入一个 String 类型的值</span></span><br><span class="line">    <span class="comment">// "xxx".to_string() 方法和 String::from("xxx") 是一样的效果</span></span><br><span class="line">    <span class="keyword">let</span> loopbackV6 = IpAddr::V6(<span class="string">"::1"</span>.to_string());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;\n&#123;:?&#125;"</span>, loopbackV4, loopbackV6);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码，我们可以给枚举的每一个成员，指定一个数据类型，并且在创建一个枚举变量的时候，将某个值存入枚举。在 <code>struct</code> 中可以存储不同类型的变量，现在，在枚举中也可以。</p><p>再来看一个例子</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个操作枚举</span></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Operation</span></span> &#123;</span><br><span class="line">    Move &#123;x: <span class="built_in">i32</span>, y:<span class="built_in">i32</span>&#125;,</span><br><span class="line">    Jump(<span class="built_in">u32</span>),</span><br><span class="line">    Attack(<span class="built_in">i32</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="comment">// 定义一个移动的操作</span></span><br><span class="line">    <span class="keyword">let</span> opt_move = Operation::Move &#123;x: <span class="number">10</span>, y: <span class="number">11</span>&#125;;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 定义一个攻击的操作</span></span><br><span class="line">    <span class="keyword">let</span> opt_attack = Operation::Attack(<span class="number">100</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 定义一个跳跃的操作</span></span><br><span class="line">    <span class="keyword">let</span> opt_jump = Operation::Jump(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    DoOperation(opt_move);</span><br><span class="line">    DoOperation(opt_attack);</span><br><span class="line">    DoOperation(opt_jump);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行操作</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">DoOperation</span></span>(opt: Operation) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Do operation: &#123;:?&#125;"</span>, opt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码我们定义了一个 <strong>Operation</strong> 枚举，里面有移动，攻击和跳跃三种操作方式。在 <strong>main</strong> 中定义了三个操作的变量，并且将每一次操作的具体值直接附加到了枚举成员上，例如 opt_attack 攻击操作，这次操作的伤害是100。</p><blockquote><p>Rust 中使用 <code>enum</code> 代替 <code>struct</code> 将获得更简洁的代码。并且，每个枚举成员可以处理不同类型和数量的数据。</p></blockquote><h2 id="Rust-的-Option-枚举解释"><a href="#Rust-的-Option-枚举解释" class="headerlink" title="Rust 的 Option 枚举解释"></a>Rust 的 Option 枚举解释</h2><p>Rust 中没有 <code>Null</code> 值，无法将一个变量赋值为 <code>Null</code>, 例如 <code>let a = Null;</code>，这样的操作在Rust中不存在。但是Rust中有 <code>Option</code> 枚举，这个枚举，用于表示 <code>存在</code> 与 <code>不存在</code> 的概念。有点抽象，没关系，一步一步来，先看下 <code>Option</code> 源代码的定义</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Option</span></span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="literal">Some</span>(T),</span><br><span class="line">  <span class="literal">None</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 <code>&lt;T&gt;</code> 是指可以代表任何数据类型的，这是范型相关的东西，后面会学习。可以将 <code>Option</code> 枚举想象成可以装不同类型东西的小盒子，例如我们定义了一个装玩具汽车的小盒子，这个小盒子里只能装玩具汽车。任何时候，只要这个盒子存在，那么里面就会有两种状态，要么有玩具汽车，要么没有玩具汽车。在有些面向对象的语言中，如果访问一个玩具汽车，而恰好当时那里没有玩具汽车，那么就会造成<code>空引用</code>，如果没有手动处理空引用的情况，则程序就会出现Bug。而Rust则避免了 <code>空引用</code> 的情况。</p><p>看下面的代码</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">  <span class="comment">// 使用 Option 将一个 String 类型的值包起来</span></span><br><span class="line">  <span class="keyword">let</span> name: <span class="built_in">Option</span>&lt;<span class="built_in">String</span>&gt; = <span class="literal">Some</span>(<span class="string">"Fred"</span>.to_string());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>Option</code> 用于某些地方可能存在有值或没值的情况。Option 及成员已经被自动包含，所以我们不需要 <code>Option::Some(xxx)</code> 这样来使用。</p></blockquote><h2 id="match-匹配"><a href="#match-匹配" class="headerlink" title="match 匹配"></a>match 匹配</h2><p>对于 <code>enum</code> 类型的值，我们不能直接比较，看下面的代码，是无法编译通过的。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">let</span> name: <span class="built_in">Option</span>&lt;<span class="built_in">String</span>&gt; = <span class="built_in">Option</span>::<span class="literal">Some</span>(<span class="string">"Jack"</span>.to_string());</span><br><span class="line"><span class="built_in">println!</span>(name == <span class="string">"Jack"</span>.to_string());</span><br></pre></td></tr></table></figure><p>上面代码中 <code>name == &quot;Jack&quot;.to_string()</code> 编译出错，因为 == 两边的数据类型不一样。这里，我们就可以用到 <code>match</code>。</p><p>看下面的代码</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Operation</span></span> &#123;</span><br><span class="line">    Move &#123;x: <span class="built_in">i32</span>, y:<span class="built_in">i32</span>&#125;,</span><br><span class="line">    Jump(<span class="built_in">u32</span>),</span><br><span class="line">    Attack(<span class="built_in">i32</span>),</span><br><span class="line">    Talk(<span class="built_in">String</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> opt_talk = Operation::Talk(<span class="string">"Hello"</span>.to_string());</span><br><span class="line">    <span class="keyword">let</span> opt_move = Operation::Move &#123; x: <span class="number">10</span>, y: <span class="number">20</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> opt_move &#123;</span><br><span class="line">        Operation::Talk(<span class="keyword">ref</span> value) =&gt; &#123; <span class="comment">// 这里加了 ref 是为了避免所有权转移</span></span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"Talk: &#123;:?&#125;"</span>, value);</span><br><span class="line">        &#125;,</span><br><span class="line">        Operation::Move &#123;x,y&#125; =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"Move, x: &#123;&#125;, y: &#123;&#125;"</span>, x, y);</span><br><span class="line">        &#125;</span><br><span class="line">        _ =&gt; &#123;</span><br><span class="line">            <span class="comment">// nothing</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中，match Operation 枚举时，并没有匹配所有的情况，所以最后需要 <code>_ =&gt;</code> ，相当于某些编译语言中 <code>switch 中的 default</code>，即在上面的情况都不匹配的情况下，执行的操作。</p><h2 id="if-let-使用"><a href="#if-let-使用" class="headerlink" title="if let 使用"></a>if let 使用</h2><p>直接看代码，简化上面 <code>match</code> 的操作</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> Operation::Move&#123;x, y&#125; = opt_move &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Move, x: &#123;&#125;, y: &#123;&#125;"</span>, x, y);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"nothing"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就可以不用 <code>match</code> 直接匹配枚举中的某一个成员类型。</p><p>感觉这篇博客有些地方写的可能不是很清楚，说明我对这块知识的理解程度还不够。下面是一些讲解 Rust 枚举的链接</p><p><a href="https://rustwiki.org/zh-CN/rust-by-example/custom_types/enum.html" target="_blank" rel="noopener">https://rustwiki.org/zh-CN/rust-by-example/custom_types/enum.html</a></p><p><a href="https://www.twle.cn/c/yufei/rust/rust-basic-enums.html" target="_blank" rel="noopener">https://www.twle.cn/c/yufei/rust/rust-basic-enums.html</a></p><p><a href="http://www.ameyalokare.com/rust/2017/10/23/rust-options.html" target="_blank" rel="noopener">http://www.ameyalokare.com/rust/2017/10/23/rust-options.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;枚举 &lt;code&gt;enum&lt;/code&gt;，用于从众多选项中选择一个。 &lt;/p&gt;
&lt;h2 id=&quot;定义枚举&quot;&gt;&lt;a href=&quot;#定义枚举&quot; class=&quot;headerlink&quot; title=&quot;定义枚举&quot;&gt;&lt;/a&gt;定义枚举&lt;/h2&gt;&lt;figure class=&quot;highlig
      
    
    </summary>
    
      <category term="Rust 基础学习" scheme="https://solleter.me/categories/Rust-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Rust" scheme="https://solleter.me/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>Rust基础学习-10-结构体的方法</title>
    <link href="https://solleter.me/2019/09/18/Rust%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0-10-%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>https://solleter.me/2019/09/18/Rust基础学习-10-结构体的方法/</id>
    <published>2019-09-18T04:30:06.000Z</published>
    <updated>2019-09-21T05:48:25.435Z</updated>
    
    <content type="html"><![CDATA[<p>这篇博客来聊一下 <code>结构体的方法</code>，本质上就是为某个结构体而定义的方法 (函数)。拿面向对象语言来说，写了一个类，还可能会在这个类里写一些方法，基本上同样的套路。或者说，定义的这些方法，是与这个结构体有关的。</p><p>不太严谨的解释，这里所谓的方法，其实就是一个函数。</p><h2 id="结构体方法的定义"><a href="#结构体方法的定义" class="headerlink" title="结构体方法的定义"></a>结构体方法的定义</h2><p>看下面的代码</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里定义一个矩形的结构体</span></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rectangle</span></span> &#123;</span><br><span class="line">    width: <span class="built_in">u32</span>,</span><br><span class="line">    height: <span class="built_in">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里的 impl xxx 是固定的，xxx 就是你要为哪一个结构体去定义一些方法</span></span><br><span class="line"><span class="keyword">impl</span> Rectangle &#123;</span><br><span class="line">    <span class="comment">// 这是一个计算面积的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">area</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">u32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width * <span class="keyword">self</span>.height</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这是一个计算周长的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">perimeter</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">u32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width * <span class="number">2</span> + <span class="keyword">self</span>.height * <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这是一个计算能否包含另一个矩形的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">can_hold</span></span>(&amp;<span class="keyword">self</span>, other: &amp;Rectangle) -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width &gt; other.width &amp;&amp; <span class="keyword">self</span>.height &gt; other.height</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>!!! 注意看上面的代码及 <code>注释</code></p><blockquote><p>结构体的<code>方法</code> 第一个参数总是 <code>&amp;self</code> 表示定义好的结构体 <code>实例</code> 自身</p></blockquote><p>下面是使用这个结构体</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> r1 = Rectangle &#123;width: <span class="number">128</span>, height: <span class="number">90</span>&#125;;</span><br><span class="line">    <span class="keyword">let</span> r2 = Rectangle &#123;width: <span class="number">50</span>, height: <span class="number">30</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:#?&#125;"</span>, r1);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:#?&#125;"</span>, r2);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用结构体的 area() 方法</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"r area: &#123;&#125;"</span>, r1.area());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用结构体的 perimeter() 方法</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"r perimeter: &#123;&#125;"</span>, r1.perimeter());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用结构体的 can_hold() 方法</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"r1 can hold r2: &#123;&#125;"</span>, r1.can_hold(&amp;r2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意上面的代码，我们打印结构体实例的时候，以前是用 <code>{:?}</code>，而这次用的是 <code>{:#?}</code>。这是因为，使用 <code>{:#?}</code> 能以更美观的方式打印出这个结构体的数据来</p></blockquote><p>如果要定义可以修改的结构体，只要加上 <code>mut</code> 就行，看下面的代码</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> r1 = Rectangle &#123;width: <span class="number">100</span>, height: <span class="number">50</span>&#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:#?&#125;"</span>, r1);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 修改了 r1 的 width</span></span><br><span class="line">    r1.width = <span class="number">1000</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:#?&#125;"</span>, r1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="关联函数"><a href="#关联函数" class="headerlink" title="关联函数"></a>关联函数</h2><p>在 <code>impl</code>  代码块中，定义一些不以 <code>&amp;self</code> 作为参数的函数，这些函数被称为 <code>关联函数</code>。就是说，这些函数，不针对某一个具体的结构体实例，而是针对这个结构体本身。</p><p>直接看下面的代码</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rectangle</span></span> &#123;</span><br><span class="line">    width: <span class="built_in">u32</span>,</span><br><span class="line">    height: <span class="built_in">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Rectangle &#123;</span><br><span class="line">    <span class="comment">// 创建一个 矩形 实例</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(width: <span class="built_in">u32</span>, height: <span class="built_in">u32</span>) -&gt; Rectangle &#123;</span><br><span class="line">        Rectangle &#123;</span><br><span class="line">            width,</span><br><span class="line">            height,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个 正方形 实例</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">new_square</span></span>(size: <span class="built_in">u32</span>) -&gt; Rectangle &#123;</span><br><span class="line">        Rectangle &#123;</span><br><span class="line">            width: size,</span><br><span class="line">            height: size,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面代码是 <code>使用</code> <code>关联函数</code></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> r1 = Rectangle::new(<span class="number">100</span>, <span class="number">80</span>);</span><br><span class="line">    <span class="keyword">let</span> r2 = Rectangle::new_square(<span class="number">100</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:#?&#125;"</span>, r1);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:#?&#125;"</span>, r2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>对于一个结构体方法的调用，我们使用 <code>r1.area()</code> 这样的形式。而对于 <code>关联函数</code> 的调用，需要使用 <code>::</code> 这个操作符。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这篇博客来聊一下 &lt;code&gt;结构体的方法&lt;/code&gt;，本质上就是为某个结构体而定义的方法 (函数)。拿面向对象语言来说，写了一个类，还可能会在这个类里写一些方法，基本上同样的套路。或者说，定义的这些方法，是与这个结构体有关的。&lt;/p&gt;
&lt;p&gt;不太严谨的解释，这里所谓的方
      
    
    </summary>
    
      <category term="Rust 基础学习" scheme="https://solleter.me/categories/Rust-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Rust" scheme="https://solleter.me/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>Rust基础学习-09-结构体的定义</title>
    <link href="https://solleter.me/2019/09/16/Rust%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0-09-%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%AE%9A%E4%B9%89/"/>
    <id>https://solleter.me/2019/09/16/Rust基础学习-09-结构体的定义/</id>
    <published>2019-09-16T11:45:06.000Z</published>
    <updated>2019-09-21T05:48:25.434Z</updated>
    
    <content type="html"><![CDATA[<p>结构体可以用于组织不同类型的数据，和一些面向对像语言中的 <code>类</code> 是很像的。</p><p>这篇博客包含以下内容</p><ul><li>结构体的定义</li><li>通过一个函数，创建并返回一个结构体</li><li>定义一个结构体，但数据来自另外一个结构体</li><li>元祖结构体</li></ul><h2 id="结构体的定义"><a href="#结构体的定义" class="headerlink" title="结构体的定义"></a>结构体的定义</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span>  <span class="comment">// 加上这一句，就可以使用 println!("&#123;:?&#125;", xxx); 打印</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">User</span></span> &#123;</span><br><span class="line">    username: <span class="built_in">String</span>,</span><br><span class="line">    email: <span class="built_in">String</span>,</span><br><span class="line">    sign_in_count: <span class="built_in">u64</span>,</span><br><span class="line">    active: <span class="built_in">bool</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结构体以 <code>struct</code> 开头，后面是我们自定义的这个结构体类型的名字，里面每一个字段，以 <code>字段名: 数据类型</code> 的形式定义</p><blockquote><p>结构体开头那个 <code>#[derive(Debug)]</code> 是为了打印而加的，也可以不加，这个的意思会在后面章节学习到，现在我也不知道具体意思，反正加上就可以使用 <code>{:?}</code> 的形式打印。</p></blockquote><p>下面这段代码创建一个结构体实例</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> user = User &#123;</span><br><span class="line">        username: <span class="built_in">String</span>::from(<span class="string">"someone"</span>),</span><br><span class="line">        email: <span class="built_in">String</span>::from(<span class="string">"someone@outlook.com"</span>),</span><br><span class="line">        sign_in_count: <span class="number">1</span>,</span><br><span class="line">        active: <span class="literal">false</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 打印这个结构体的内容</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, user);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 因为创建 user 的时候加了 mut，所以可以修改里面字段的内容</span></span><br><span class="line">    user.active = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Changed: &#123;:?&#125;"</span>, user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="通过一个函数，创建并返回一个结构体"><a href="#通过一个函数，创建并返回一个结构体" class="headerlink" title="通过一个函数，创建并返回一个结构体"></a>通过一个函数，创建并返回一个结构体</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">build_user</span></span>(_username: <span class="built_in">String</span>, _email: <span class="built_in">String</span>) -&gt; User &#123;</span><br><span class="line">    User &#123;</span><br><span class="line">        username: _username,</span><br><span class="line">        email: _email,</span><br><span class="line">        sign_in_count: <span class="number">2</span>,</span><br><span class="line">        active: <span class="literal">false</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果参数名和结构体的字段名相同，则可以直接按下面的方式去赋值，</span></span><br><span class="line"><span class="comment">// 不需要再 aaa:bbb 这样的形式，并且顺序也无所谓</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">build_user2</span></span>(username: <span class="built_in">String</span>, email: <span class="built_in">String</span>) -&gt; User &#123;</span><br><span class="line">    User &#123;</span><br><span class="line">        email,</span><br><span class="line">        username,</span><br><span class="line">        sign_in_count: <span class="number">2</span>,</span><br><span class="line">        active: <span class="literal">false</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="定义一个结构体，但数据来自另外一个结构体"><a href="#定义一个结构体，但数据来自另外一个结构体" class="headerlink" title="定义一个结构体，但数据来自另外一个结构体"></a>定义一个结构体，但数据来自另外一个结构体</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">User</span></span> &#123;</span><br><span class="line">    username: <span class="built_in">String</span>,</span><br><span class="line">    email: <span class="built_in">String</span>,</span><br><span class="line">    sign_in_count: <span class="built_in">u64</span>,</span><br><span class="line">    active: <span class="built_in">bool</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> user = User &#123;</span><br><span class="line">        username: <span class="built_in">String</span>::from(<span class="string">"someone"</span>),</span><br><span class="line">        email: <span class="built_in">String</span>::from(<span class="string">"someone@outlook.com"</span>),</span><br><span class="line">        sign_in_count: <span class="number">1</span>,</span><br><span class="line">        active: <span class="literal">false</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, user);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">let</span> user2 = User &#123;</span><br><span class="line">        username: <span class="built_in">String</span>::from(<span class="string">"user2"</span>),</span><br><span class="line">        email: <span class="built_in">String</span>::from(<span class="string">"user2@outlook.com"</span>),</span><br><span class="line">        sign_in_count: user.sign_in_count,<span class="comment">// 使用 user 实例的数据</span></span><br><span class="line">        active: user.active,  <span class="comment">// 这个也使用 user 实例的数据</span></span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 除了 username 和 email, 其他字段都使用 user 的值</span></span><br><span class="line">    <span class="keyword">let</span> user3 = User &#123;</span><br><span class="line">        username: <span class="built_in">String</span>::from(<span class="string">"user3"</span>),</span><br><span class="line">        email: <span class="built_in">String</span>::from(<span class="string">"user3@outlook.com"</span>),</span><br><span class="line">        ..user</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码，使用其他结构体数据，创建新的结构体时，我们使用的都是 <code>简单</code> 的 <code>数据类型</code>。如果使用 String 类型的字段，例如 username 或 email，则原有结构体实例的数据，会移动到新的结构体实例。看下面的代码。</p><p>下面这段代码编译会出错。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">User</span></span> &#123;</span><br><span class="line">    username: <span class="built_in">String</span>,</span><br><span class="line">    email: <span class="built_in">String</span>,</span><br><span class="line">    sign_in_count: <span class="built_in">u64</span>,</span><br><span class="line">    active: <span class="built_in">bool</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> user = User &#123;</span><br><span class="line">        username: <span class="built_in">String</span>::from(<span class="string">"someone"</span>),</span><br><span class="line">        email: <span class="built_in">String</span>::from(<span class="string">"someone@outlook.com"</span>),</span><br><span class="line">        sign_in_count: <span class="number">1</span>,</span><br><span class="line">        active: <span class="literal">false</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> user2 = User &#123;</span><br><span class="line">        ..user</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// !!!! 这一句编译会出错，因为我们创建 user2 的时候，使用了所有 user的数据，</span></span><br><span class="line">    <span class="comment">// 因为 username 和 email是String类型的，所以 所有权 会移动到 user2的对应字段中</span></span><br><span class="line">    <span class="comment">// 所以这句就会报错 !!!</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, user.username);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要修复错误，可以使用我们上一节学到的切片，直接看下面的代码</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">User</span></span> &#123;</span><br><span class="line">    username: <span class="built_in">String</span>,</span><br><span class="line">    email: <span class="built_in">String</span>,</span><br><span class="line">    sign_in_count: <span class="built_in">u64</span>,</span><br><span class="line">    active: <span class="built_in">bool</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> user = User &#123;</span><br><span class="line">        username: <span class="built_in">String</span>::from(<span class="string">"someone"</span>),</span><br><span class="line">        email: <span class="built_in">String</span>::from(<span class="string">"someone@outlook.com"</span>),</span><br><span class="line">        sign_in_count: <span class="number">1</span>,</span><br><span class="line">        active: <span class="literal">false</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> user2 = User &#123;</span><br><span class="line">        username: <span class="built_in">String</span>::from(&amp;user.username[..]), <span class="comment">// !!! 注意看这句</span></span><br><span class="line">        email: <span class="built_in">String</span>::from(&amp;user.email[..]), <span class="comment">// !!! 还有这一句</span></span><br><span class="line">        ..user</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, user.username);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, user);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, user2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码，在创建 user2 时，String类型的字段，我们通过切片，创建了新的 String 数据，所以没有导致 <code>所有权</code> 转移。</p><h2 id="元祖结构体"><a href="#元祖结构体" class="headerlink" title="元祖结构体"></a>元祖结构体</h2><p>有一种结构体，没有具体的字段名，只有类型，这种结构体，称为 <code>元祖结构体 (tuple structs)</code>。看下面的代码</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Color</span></span>(<span class="built_in">i32</span>, <span class="built_in">i32</span>, <span class="built_in">i32</span>, <span class="built_in">i32</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> bg_color = Color(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, bg_color);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通过所引，访问结构体里的某个元素，与 元祖 的访问方式一样</span></span><br><span class="line">    <span class="keyword">let</span> r = bg_color.<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> g = bg_color.<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> b = bg_color.<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">let</span> a = bg_color.<span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一节聊了一下结构体的基本知识，下一节将聊一下更多关于结构体的东西。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;结构体可以用于组织不同类型的数据，和一些面向对像语言中的 &lt;code&gt;类&lt;/code&gt; 是很像的。&lt;/p&gt;
&lt;p&gt;这篇博客包含以下内容&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;结构体的定义&lt;/li&gt;
&lt;li&gt;通过一个函数，创建并返回一个结构体&lt;/li&gt;
&lt;li&gt;定义一个结构体，但数据来自
      
    
    </summary>
    
      <category term="Rust 基础学习" scheme="https://solleter.me/categories/Rust-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Rust" scheme="https://solleter.me/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>Rust基础学习-08-关于切片</title>
    <link href="https://solleter.me/2019/09/14/Rust%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0-08-%E5%85%B3%E4%BA%8E%E5%88%87%E7%89%87/"/>
    <id>https://solleter.me/2019/09/14/Rust基础学习-08-关于切片/</id>
    <published>2019-09-14T07:13:52.000Z</published>
    <updated>2019-09-14T08:03:45.651Z</updated>
    
    <content type="html"><![CDATA[<p>这篇博客有以下内容</p><ul><li><p>字符串切片解释</p></li><li><p>通用切片</p></li><li><p><code>String</code>，<code>&amp;String</code>，<code>&amp;str</code> 的区别</p><a id="more"></a></li></ul><blockquote><p>注意: <code>&amp;str 就是字符串切片</code></p></blockquote><h2 id="字符串切片"><a href="#字符串切片" class="headerlink" title="字符串切片"></a>字符串切片</h2><p>字符串切片可以理解为一个指向字符串部分数据的不可变的引用（指针）</p><p>看下面的代码</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="comment">// 这是一个 String</span></span><br><span class="line">    <span class="keyword">let</span> welcome = <span class="built_in">String</span>::from(<span class="string">"Hello, Rust"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这是一个字符串引用，&amp;String</span></span><br><span class="line">    <span class="keyword">let</span> rs = &amp;welcome;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这是一个切片，welcome的部分引用，</span></span><br><span class="line">    <span class="comment">// 从第0个字符，到第5个字符，但是不包含第5个字符</span></span><br><span class="line">    <span class="keyword">let</span> s1 = &amp;welcome[<span class="number">0</span>..<span class="number">5</span>];</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"s1: &#123;&#125;"</span>, s1); <span class="comment">// Hello</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个切片，从第0个字符，到第5个字符，包含第5个字符</span></span><br><span class="line">    <span class="keyword">let</span> s2 = &amp;welcome[<span class="number">0</span>..=<span class="number">5</span>];</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"s2: &#123;&#125;"</span>, s2); <span class="comment">// Hello,</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 与 [0..5]是一样的，同样也可以 [0..=5]包含第5个字符</span></span><br><span class="line">    <span class="keyword">let</span> s3 = &amp;welcome[..<span class="number">5</span>]; <span class="comment">// Hello</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果省略最后一个字符，则直接截取到字符串最后</span></span><br><span class="line">    <span class="keyword">let</span> s4 = &amp;welcome[<span class="number">0</span>..]; <span class="comment">// Hello, Rust</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 整个字符串的切片</span></span><br><span class="line">    <span class="keyword">let</span> s5 = &amp;welcome[..]; <span class="comment">// Hello, Rust</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"s3: &#123;&#125;\ns4: &#123;&#125;\ns5: &#123;&#125;"</span>, s3, s4, s5);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这也是一个切片</span></span><br><span class="line">    <span class="keyword">let</span> s3 = <span class="string">"Jack"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码每一行都有解释，输出如下</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s1: Hello</span><br><span class="line">s2: Hello,</span><br><span class="line">s3: Hello</span><br><span class="line">s4: Hello, Rust</span><br><span class="line">s5: Hello, Rust</span><br></pre></td></tr></table></figure><h2 id="通用切片"><a href="#通用切片" class="headerlink" title="通用切片"></a>通用切片</h2><p>切片不光可以用与字符串，还可以用于数组，看下面的代码</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span> ,<span class="number">3</span> ,<span class="number">4</span> ,<span class="number">5</span>];</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, &amp;a[<span class="number">0</span>..<span class="number">2</span>]);<span class="comment">// 输出 [1,2]</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, &amp;a[<span class="number">0</span>..=<span class="number">2</span>]);  <span class="comment">// 输出 [1,2,3]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="String-amp-String-amp-str-的区别"><a href="#String-amp-String-amp-str-的区别" class="headerlink" title="String, &amp;String, &amp;str 的区别"></a>String, &amp;String, &amp;str 的区别</h2><ul><li><code>String</code> 是一个可变的字符串结构</li><li><code>&amp;String</code> 是一个完整的字符串的引用</li><li><code>&amp;str</code> 是一个字符串切片，一个不可变的，字符串的部分引用</li></ul><p>平时使用的 <code>String::from</code> 其实就是通过一个字符串切片，创建一个可变字符串结构，看下面的代码</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> str1 = <span class="built_in">String</span>::from(<span class="string">"Hello, Rust"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> s1 = <span class="string">"Hello, Rust"</span>;</span><br><span class="line">    <span class="keyword">let</span> str2 = <span class="built_in">String</span>::from(s1);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"str1: &#123;&#125;\nstr2: &#123;&#125;"</span>, str1, str2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码，<code>str1</code> 和 <code>str2</code> 的内容是一样的。</p><h2 id="amp-String-和-amp-str-作为函数参数的区别"><a href="#amp-String-和-amp-str-作为函数参数的区别" class="headerlink" title="&amp;String 和 &amp;str 作为函数参数的区别"></a>&amp;String 和 &amp;str 作为函数参数的区别</h2><p>看下面的代码</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> str1 = <span class="built_in">String</span>::from(<span class="string">"Hello, Rust"</span>);</span><br><span class="line">    func1(&amp;str1);</span><br><span class="line">    func2(&amp;<span class="keyword">mut</span> str1);</span><br><span class="line">    func3(&amp;str1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串不可变引用作为函数参数</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">func1</span></span>(s: &amp;<span class="built_in">String</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"s: &#123;&#125;"</span>, s);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"len: &#123;&#125; capacity: &#123;&#125;"</span>, s.len(), s.capacity());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串可变引用作为函数参数，这里改变了原字符串内容</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">func2</span></span>(s: &amp;<span class="keyword">mut</span> <span class="built_in">String</span>) &#123;</span><br><span class="line">    s.push_str(<span class="string">" haha"</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"changed: &#123;&#125;"</span>, s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不可变的字符串切片作为函数参数，字符串切片没有 capacity() 函数</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">func3</span></span>(s: &amp;<span class="built_in">str</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"slice :&#123;&#125;"</span>, s);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"len: &#123;&#125;"</span>, s.len());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里要解释的一点是，作为函数参数，如果字符串切片 <code>&amp;str</code> 能满足要求，则推荐使用字符串切片，而不是整个字符串的引用。第5行代码调用func3的时候，传递的是整个字符串的引用，可以理解为&amp;String 和 &amp;str是可以互相转换的。</p><ul><li><p>字符串切片 <code>&amp;str</code> 是不可变的</p></li><li><p>如果函数只读使用字符串，则推荐使用字符串切片 <code>&amp;str</code> 作为函数参数</p></li><li>字符串切片有 <code>len()</code> 函数，但是没有 <code>capacity()</code> 函数</li><li>字符串引用 <code>&amp;String</code> 有 <code>len()</code> 和 <code>capacity()</code> 函数</li><li>如果要改变字符串，或者读取字符串的长度，则使用字符串引用 <code>&amp;String</code> 作为参数</li><li>如果要获取字符串的所有权，则使用 <code>String</code> 作为参数。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇博客有以下内容&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;字符串切片解释&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;通用切片&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;String&lt;/code&gt;，&lt;code&gt;&amp;amp;String&lt;/code&gt;，&lt;code&gt;&amp;amp;str&lt;/code&gt; 的区别&lt;/p&gt;
    
    </summary>
    
      <category term="Rust 基础学习" scheme="https://solleter.me/categories/Rust-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Rust" scheme="https://solleter.me/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>Rust基础学习-07-通俗解释引用与借用</title>
    <link href="https://solleter.me/2019/09/14/Rust%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0-07-%E5%BC%95%E7%94%A8%E4%B8%8E%E5%80%9F%E7%94%A8%E7%9A%84%E8%A7%A3%E9%87%8A/"/>
    <id>https://solleter.me/2019/09/14/Rust基础学习-07-引用与借用的解释/</id>
    <published>2019-09-14T05:56:30.000Z</published>
    <updated>2019-09-14T06:34:24.283Z</updated>
    
    <content type="html"><![CDATA[<p>今天我们来学习一下Rust中的引用与借用。我在看官方教程讲解引用与借用的时候，很困惑，分不清引用与借用。在第二遍理解的时候，大概能够理清了。</p><p>先来解释一下 <code>引用</code>，Rust官方文档中的解释是 <code>允许使用值但不获取其所有权</code>。与其他语言基本一样，可以理解为就是一个数据指针。</p><p>再来说一下 <code>借用</code>，官方文档中解释借用是指 <code>将获取引用作为函数参数称为 借用（borrowing）</code>。我的理解是，<code>借用</code>不是一个具体的东西，而是一种行为，对于Rust来说，当我们定义一下函数，而函数的形参是一个引用，或者说是一个指针时，这种行为，就叫做借用。可能不太精确地解释，可以理解为，当我们调用这个函数时，这个函数借用了外面某个数据的访问权限，但是并不拥有外面数据的所有权。就像生活中你借了某人的一个网站账号，这时，你可以访问网站上的内容了，但是你没有这个账号的所有权。</p><blockquote><p>当将引用作为参数时，也分为 <code>可变引用</code> 和 <code>不可变引用</code></p></blockquote><h2 id="不可变引用"><a href="#不可变引用" class="headerlink" title="不可变引用"></a>不可变引用</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> <span class="built_in">str</span> = <span class="built_in">String</span>::from(<span class="string">"Hello"</span>);</span><br><span class="line">    borrowing(&amp;<span class="built_in">str</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">borrowing</span></span>(<span class="built_in">str</span>: &amp;<span class="built_in">String</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Borrowing Str: &#123;&#125;"</span>, <span class="built_in">str</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="可变引用"><a href="#可变引用" class="headerlink" title="可变引用"></a>可变引用</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> <span class="built_in">str</span> = <span class="built_in">String</span>::from(<span class="string">"Hello"</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Source Str: &#123;&#125;"</span>, <span class="built_in">str</span>);<span class="comment">// 这里打印出原来的字符串</span></span><br><span class="line">    mut_borrowing(&amp;<span class="keyword">mut</span> <span class="built_in">str</span>);<span class="comment">// 调用后，字符串被改变</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Str: &#123;&#125;"</span>, <span class="built_in">str</span>); <span class="comment">// 打印改变后的字符串</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">mut_borrowing</span></span>(<span class="built_in">str</span>: &amp;<span class="keyword">mut</span> <span class="built_in">String</span>) &#123;</span><br><span class="line">    <span class="built_in">str</span>.push_str(<span class="string">" , Rust"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>有一条很重要的规则要记住，在同一作用域中，一个数据，有且只有一个 <code>可变</code> 引用。</p></blockquote><p>下面一段代码就是错的，编译不过，因为同一作用域下，同一个数据有多个可变引用</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> <span class="built_in">str</span> = <span class="built_in">String</span>::from(<span class="string">"Hello"</span>);</span><br><span class="line">    <span class="keyword">let</span> r1 = &amp;<span class="keyword">mut</span> <span class="built_in">str</span>;</span><br><span class="line">    <span class="keyword">let</span> r2 = &amp;<span class="keyword">mut</span> <span class="built_in">str</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;, &#123;&#125;"</span>, r1, r2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="关于数据竞争"><a href="#关于数据竞争" class="headerlink" title="关于数据竞争"></a>关于数据竞争</h2><p>Rust 这样的限制可以避免<code>数据竞争</code>，数据竞争可能由下面三个原因引起</p><ul><li>两个或更多指针同时访问同一数据。</li><li>至少有一个指针被用来写入数据。</li><li>没有同步数据访问的机制。</li></ul><h2 id="悬垂引用（Dangling-References）"><a href="#悬垂引用（Dangling-References）" class="headerlink" title="悬垂引用（Dangling References）"></a>悬垂引用（Dangling References）</h2><p>在拥有指针的编程语言中很容易出现一种情况，一个指针还存在，但是指针指向的内存已经被释放。在Rust中，这种为<code>悬垂引用</code>。在Rust中，Rust编译器确保指针永远不会变为悬垂状态。</p><p>看下面的代码，编译会出错</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> s = dangling();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个函数返回了字符串的引用，但是当这个函数结束时，字符串内存会被释放，&amp;s变为悬垂状态，所以编译出错</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">dangling</span></span>() -&gt; &amp;<span class="built_in">String</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> s = <span class="built_in">String</span>::from(<span class="string">"Hello rust"</span>);</span><br><span class="line">    &amp;s </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="引用的规则"><a href="#引用的规则" class="headerlink" title="引用的规则"></a>引用的规则</h2><ul><li>在任意给定时间，<strong>要么</strong> 只能有一个可变引用，<strong>要么</strong> 只能有多个不可变引用。</li><li>引用必须总是有效。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天我们来学习一下Rust中的引用与借用。我在看官方教程讲解引用与借用的时候，很困惑，分不清引用与借用。在第二遍理解的时候，大概能够理清了。&lt;/p&gt;
&lt;p&gt;先来解释一下 &lt;code&gt;引用&lt;/code&gt;，Rust官方文档中的解释是 &lt;code&gt;允许使用值但不获取其所有权&lt;/c
      
    
    </summary>
    
      <category term="Rust 基础学习" scheme="https://solleter.me/categories/Rust-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Rust" scheme="https://solleter.me/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>Rust基础学习-06-所有权、作用域</title>
    <link href="https://solleter.me/2019/09/11/Rust%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0-06-%E6%89%80%E6%9C%89%E6%9D%83%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    <id>https://solleter.me/2019/09/11/Rust基础学习-06-所有权、作用域/</id>
    <published>2019-09-11T02:13:33.000Z</published>
    <updated>2019-09-11T13:47:50.125Z</updated>
    
    <content type="html"><![CDATA[<p>本篇博客我们来解释几个名词，<strong><code>栈</code></strong>、<strong><code>堆</code></strong>、<strong><code>作用域</code></strong>、<strong><code>所有权</code></strong>、<strong><code>所有权移动</code></strong></p><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>栈是在代码运行时，可供使用的一块内存。它的存取数据方式是<code>先进后出</code>，或者说<code>后进先出</code>。想象有一个箱子，你往里放本子，最先放入的本子，是在箱子底下，当你要使用本子时，总是从顶上取一个使用，也就是取最后放入的一个本子。<br><strong>因为这种存取数据时总是在栈顶操作，而不需要去内存中寻找一个位置，所以栈的操作是时分迅速的。</strong><br>还有一个点是，存在栈里的数据，都是以知的固定大小。这一点的意思是，<em>例如要让用户输入一个名字，因为不知道用户会输入多少字符，所以这个数据就无法放在栈中，因为无法事先知道明确的大小。</em></p><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>在编译时大小未知或大小可能变化的数据，要改为存储在堆上。堆是缺乏组织的：当向堆放入数据时，你要请求一定大小的空间。操作系统在堆的某处找到一块足够大的空位，把它标记为已使用，并返回一个表示该位置地址的 <code>指针（pointer）</code>。这个过程称作 在堆上分配内存<code>（allocating on the heap）</code>，有时简称为 <code>分配（allocating）</code>。</p><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>作用域可以理解为一个东西在程序中的有效范围。对于Rust来说，当一个变量出了作用域后，对应的内存就会自动被释放掉，变量变为无效状态。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;                      <span class="comment">// s 在这里无效, 它尚未声明</span></span><br><span class="line">    <span class="keyword">let</span> s = <span class="string">"hello"</span>;   <span class="comment">// 从此处起，s 是有效的</span></span><br><span class="line">    <span class="comment">// 使用 s</span></span><br><span class="line">&#125;                      <span class="comment">// 此作用域已结束，s 不再有效</span></span><br></pre></td></tr></table></figure></p><h2 id="字符串类型-String"><a href="#字符串类型-String" class="headerlink" title="字符串类型 String"></a>字符串类型 String</h2><p>之前在数据类型一节，没有讲到 String，是因为牵扯到堆栈的问题，所以放在这里讲。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="comment">// 像这种直接硬编码在代码里的字符串，是放在栈上的，并且不可改变</span></span><br><span class="line">    <span class="keyword">let</span> name = <span class="string">"Jack"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用String::from创建的，是在堆上分配内存，并且是可以改变的</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> my_name = <span class="built_in">String</span>::from(<span class="string">"Jack"</span>);</span><br><span class="line">    my_name.push_str(<span class="string">", My name is Jack"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出 Jack, My name is Jack</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, my_name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>当调用 <code>String::from</code> 时，它的实现 (implementation) 请求其所需的内存。这在编程语言中是非常通用的。</p></blockquote><h2 id="所有权"><a href="#所有权" class="headerlink" title="所有权"></a>所有权</h2><ol><li>Rust 中每一个值都有一个被称为<strong><code>所有者</code></strong>的变量</li><li>值，有且只有一个所有者</li><li>当所有者（变量）离开作用域时，这个值被丢弃，内存被释放</li></ol><h2 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h2><p>先看下面一段代码<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">let</span> y = x;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"x: &#123;&#125;, y:&#123;&#125;"</span>, x, y);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> name1 = <span class="string">"Fred"</span>;</span><br><span class="line">    <span class="keyword">let</span> name2 = name1;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"name1: &#123;&#125;, name2: &#123;&#125;"</span>, name1, name2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>很正常，最后输出了 <code>x: 10, y:10</code> 和 <code>name1: Fred, name2: Fred</code></p><p>再看下面这段代码<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> name1 = <span class="built_in">String</span>::from(<span class="string">"Fred"</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"name1: &#123;&#125;"</span>, name1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> name2 = name1;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"name2: &#123;&#125;"</span>, name2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编译出错，这句会出错</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"name1 again: &#123;&#125;"</span>, name1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>为什么加了最后一句会编译出错呢，这里涉及到一个概念，<code>移动</code>。首先 name1 指向的值是分配在堆上的。当将 name1 赋值 给 name2后，在有一些编程语言，两个变量会指向同一块堆内存区域，但是对于Rust来说，不是这样的，Rust在这里会直接让 name1 <code>失效</code>，避免两个指针指向同一块堆内存。因为 Rust 会自动释放内存，这样可以避免当两个变量超出作用域时，导致重复的内存释放问题。将 name1 赋值给 name2，这个操作叫做<code>移动</code>，name1移动到了name2，移动后，name1自动失效，所以最后一句访问 name1 会编译出错。</p><p>更详细的内容 <a href="https://kaisery.github.io/trpl-zh-cn/ch04-01-what-is-ownership.html" target="_blank" rel="noopener">官方文档</a></p><blockquote><p>这里要记住，对于那些固定大小的数据类型，<code>i32</code>, <code>f32</code>, <code>bool</code>，<code>char</code> 等不会存在<code>移动</code>的问题。但是对于存储在<code>堆</code>上的数据，不管是String还是后面自定义的数据类型，这样的操作都会触发<code>移动</code></p></blockquote><h4 id="有没有办法将指上堆内存的变量赋值给另一个变量不触发移动呢？有！方法就是克隆，看下面的代码。"><a href="#有没有办法将指上堆内存的变量赋值给另一个变量不触发移动呢？有！方法就是克隆，看下面的代码。" class="headerlink" title="有没有办法将指上堆内存的变量赋值给另一个变量不触发移动呢？有！方法就是克隆，看下面的代码。"></a>有没有办法将指上堆内存的变量赋值给另一个变量不触发<code>移动</code>呢？有！方法就是克隆，看下面的代码。</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> name1 = <span class="built_in">String</span>::from(<span class="string">"Fred"</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"name1: &#123;&#125;"</span>, name1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> name2 = name1.clone();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"name2: &#123;&#125;"</span>, name2);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"name1 again: &#123;&#125;"</span>, name1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和之前的代码只有第5行变了，当调用了 <code>clone()</code>函数后，会导致 name1 指向的堆上的内存复制一份。所以这里就没有<code>移动</code>。String内部实现了 <code>clone()</code>，当我们自定义数据结构时，如果要有克隆功能，需要自己实现 <code>clone()</code>方法。这个后面会讲到。</p><h2 id="移动与函数"><a href="#移动与函数" class="headerlink" title="移动与函数"></a>移动与函数</h2><p>说完了<code>移动</code>，就需要说一下移动和函数相关的东西。如果将一个值作为参数，去调用一个函数，如果这个值是在栈上，那么不会发生什么，但是如果这个值是分配在堆上，那么它会移动到函数内部。</p><p>看下面的代码（注意看代码的注释）<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> name1 = <span class="built_in">String</span>::from(<span class="string">"Fred"</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"name1: &#123;&#125;"</span>, name1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// name1 的值移动了函数里</span></span><br><span class="line">    takes_ownership((name1));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// name1 已经无效，这里再使用就会编译出错</span></span><br><span class="line">    <span class="comment">// println!("name1 again: &#123;&#125;", name1);</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">takes_ownership</span></span>(<span class="built_in">str</span>: <span class="built_in">String</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"i have ownership: &#123;&#125;"</span>, <span class="built_in">str</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面的代码，函数在结束时将 <code>所有权</code> 返回<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> name1 = <span class="built_in">String</span>::from(<span class="string">"Fred"</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"name1: &#123;&#125;"</span>, name1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为name1不是mut的，所以这里的name1相当于创建了一个</span></span><br><span class="line">    <span class="comment">// 新的变量name1, 本质上并不是之前的</span></span><br><span class="line">    <span class="keyword">let</span> name1 = takes_and_gives_back(name1);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"name1 again: &#123;&#125;"</span>, name1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">takes_and_gives_back</span></span>(<span class="built_in">str</span>: <span class="built_in">String</span>) -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"i have ownership: &#123;&#125;"</span>, <span class="built_in">str</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这里将值返回，所有权移出函数</span></span><br><span class="line">    <span class="built_in">str</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="使用函数时每次都要转移所有权很繁琐，所下一节将介绍引用，不用每次将所有权转来转去"><a href="#使用函数时每次都要转移所有权很繁琐，所下一节将介绍引用，不用每次将所有权转来转去" class="headerlink" title="使用函数时每次都要转移所有权很繁琐，所下一节将介绍引用，不用每次将所有权转来转去"></a>使用函数时每次都要转移所有权很繁琐，所下一节将介绍<code>引用</code>，不用每次将所有权转来转去</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本篇博客我们来解释几个名词，&lt;strong&gt;&lt;code&gt;栈&lt;/code&gt;&lt;/strong&gt;、&lt;strong&gt;&lt;code&gt;堆&lt;/code&gt;&lt;/strong&gt;、&lt;strong&gt;&lt;code&gt;作用域&lt;/code&gt;&lt;/strong&gt;、&lt;strong&gt;&lt;code&gt;所有权&lt;/code&gt;&lt;
      
    
    </summary>
    
      <category term="Rust 基础学习" scheme="https://solleter.me/categories/Rust-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Rust" scheme="https://solleter.me/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>Rust基础学习-05-if、loop、while、for</title>
    <link href="https://solleter.me/2019/09/08/Rust%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0-05-if%E3%80%81loop%E3%80%81while%E3%80%81for/"/>
    <id>https://solleter.me/2019/09/08/Rust基础学习-05-if、loop、while、for/</id>
    <published>2019-09-08T13:52:27.000Z</published>
    <updated>2019-09-11T13:47:50.124Z</updated>
    
    <content type="html"><![CDATA[<p>这一篇博客来写一下基本的分支和循环，<code>if</code>、<code>else if</code>、<code>loop</code>、<code>while</code>、<code>for</code></p><h2 id="if-else"><a href="#if-else" class="headerlink" title="if else"></a>if else</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span> x &gt; <span class="number">100</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"x &gt; 100"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> x &gt; <span class="number">50</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"x &gt; 50"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"x &lt;= 50"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 还可以这样写</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> condition = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="keyword">if</span> condition &#123;</span><br><span class="line">        <span class="number">5</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="number">6</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="loop"><a href="#loop" class="headerlink" title="loop"></a>loop</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这段代码中，break counter * 100; 这一句是将和跳出循环，并把 counter * 100 返回</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="keyword">loop</span> &#123;</span><br><span class="line">        counter += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> counter == <span class="number">10</span> &#123;</span><br><span class="line">            <span class="keyword">break</span> counter * <span class="number">100</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"x: &#123;&#125;"</span>, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="while"><a href="#while" class="headerlink" title="while"></a>while</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> counter = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">while</span> counter &gt;= <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"counter: &#123;&#125;"</span>, counter);</span><br><span class="line">        counter -= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="for"><a href="#for" class="headerlink" title="for"></a>for</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这段代码将输出，0 到 9</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span>(<span class="number">0</span>..<span class="number">10</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"x: &#123;&#125;"</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 for 循环来遍历集合中的元素</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> nums = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">20</span>];</span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums.iter() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"num: &#123;&#125;"</span>, num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这一篇博客来写一下基本的分支和循环，&lt;code&gt;if&lt;/code&gt;、&lt;code&gt;else if&lt;/code&gt;、&lt;code&gt;loop&lt;/code&gt;、&lt;code&gt;while&lt;/code&gt;、&lt;code&gt;for&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;if-else&quot;&gt;&lt;a href
      
    
    </summary>
    
      <category term="Rust 基础学习" scheme="https://solleter.me/categories/Rust-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Rust" scheme="https://solleter.me/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>Rust基础学习-04-函数和表达式</title>
    <link href="https://solleter.me/2019/09/08/Rust%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0-04-%E5%87%BD%E6%95%B0%E5%92%8C%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>https://solleter.me/2019/09/08/Rust基础学习-04-函数和表达式/</id>
    <published>2019-09-08T13:27:01.000Z</published>
    <updated>2019-09-11T13:47:50.124Z</updated>
    
    <content type="html"><![CDATA[<h2 id="函数的定义"><a href="#函数的定义" class="headerlink" title="函数的定义"></a>函数的定义</h2><p>Rust 函数的定义是以 <code>fn</code> 开头，<code>main</code> 函数是Rust程序的入口函数<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="comment">// main 函数是Rust程序的入口点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个普通的函数</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">func1</span></span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"hello"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个带有返回值的函数，返回类型是 i32</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">func2</span></span>() -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">return</span> x + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个带参数的函数</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">func3</span></span>(x: <span class="built_in">i32</span>, y: <span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h2><blockquote><p><code>语句</code>，是执行一些操作，但不返回值的指令。<br><code>表达式</code>，计算并产生一个值</p></blockquote><p>这一点与其他语言不同，看下面的代码</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> value = &#123;</span><br><span class="line">    <span class="keyword">let</span> v1 = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">let</span> v2 = <span class="number">200</span>;</span><br><span class="line">    v1 + v2</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面是一个代码块，在代码块里定义了两个变量，注意看最后一句代码，执行了 <code>v1 + v2</code>，但是这一句结尾没有 <code>;</code>，这就是一个表达式，这个代码块执行了计算，并返回了一个值，这个值就是 <code>v1 + v2</code>。</p><p>再来看一个例子<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">sum</span></span>(x: <span class="built_in">i32</span>, y: <span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">    x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面这个函数计算了两个数的和，在以前，函数返回值我们会用 <code>return x + y</code>，但是现在，我们也可以不用 <code>return</code>，直接将 <code>x + y</code> 放在函数最后，作为函数的返回值。</p><blockquote><p>重点要注意的是，表达式结尾不要加<code>分号</code></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;函数的定义&quot;&gt;&lt;a href=&quot;#函数的定义&quot; class=&quot;headerlink&quot; title=&quot;函数的定义&quot;&gt;&lt;/a&gt;函数的定义&lt;/h2&gt;&lt;p&gt;Rust 函数的定义是以 &lt;code&gt;fn&lt;/code&gt; 开头，&lt;code&gt;main&lt;/code&gt; 函数是Rust程
      
    
    </summary>
    
      <category term="Rust 基础学习" scheme="https://solleter.me/categories/Rust-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Rust" scheme="https://solleter.me/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>Rust基础学习-03-变量常量和基本数据类型</title>
    <link href="https://solleter.me/2019/09/01/Rust%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0-03-%E5%8F%98%E9%87%8F%E5%B8%B8%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>https://solleter.me/2019/09/01/Rust基础学习-03-变量常量和基本数据类型/</id>
    <published>2019-09-01T06:41:39.000Z</published>
    <updated>2019-09-11T13:47:50.123Z</updated>
    
    <content type="html"><![CDATA[<p>这里来聊一下Rust的变量声明，以及基本的数据类型。</p><h2 id="可变性"><a href="#可变性" class="headerlink" title="可变性"></a>可变性</h2><p>与其他编程语言很不同的一点是，Rust 的变量默认是不可变的。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">5</span>;</span><br><span class="line">x = <span class="number">6</span>;</span><br></pre></td></tr></table></figure></p><blockquote><p>这一步编译会报错，因为rust的变量默认是不可变的。</p></blockquote><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> x = <span class="number">5</span>;</span><br><span class="line">x = <span class="number">6</span>;</span><br></pre></td></tr></table></figure><blockquote><p>在变量前加上 mut 则表示正在定义一个可变变量，再改其值，就不会报错。</p></blockquote><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> x = <span class="number">6</span>; </span><br><span class="line"><span class="keyword">let</span> x = <span class="string">"name"</span>;</span><br></pre></td></tr></table></figure><blockquote><p>1.定义一个变量，并将5这个值绑定给这个变量<br>2.重新使用 <code>let x</code> 定义一个变量，相当于定义了一个新的变量，并且将6绑定给这个变量<br>3.再次使用 <code>let x</code> 定义一个变量，并且绑定一个不同类型的值<br>上面的三行代码不会报错，在Rust中，这个操作叫做 <code>Shadowing</code>，中文翻译是，旧的变量被新的变量隐藏了。</p></blockquote><p><strong><code>mut</code> 与 <code>Shadowing</code> 的一个区别就是，<code>Shadowing</code> 相当于创建了一个新的变量，所以可以使用完全不同类型的值</strong></p><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><ol><li>声明常量使用 <code>const</code>，不使用 <code>let</code>，例如 <code>const MAX_NUM:u32 = 10000;</code>。</li><li>常量也<code>不能</code>使用 <code>mut</code>。</li><li>常量必须明确数据类型 const <code>MAX_NUM:u32</code> = 10000;</li><li>常量默认<code>不可变</code>，总是<code>不可变</code></li><li>常量命名规范是<code>大写字母加下划线</code></li></ol><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><h4 id="1-整型"><a href="#1-整型" class="headerlink" title="1. 整型"></a>1. 整型</h4><table><thead><tr><th style="text-align:center">长度</th><th style="text-align:center">有符号</th><th style="text-align:center">无符号</th></tr></thead><tbody><tr><td style="text-align:center">8-bit</td><td style="text-align:center"><code>i8</code></td><td style="text-align:center"><code>u8</code></td></tr><tr><td style="text-align:center">16-bit</td><td style="text-align:center"><code>i16</code></td><td style="text-align:center"><code>u16</code></td></tr><tr><td style="text-align:center">32-bit</td><td style="text-align:center"><code>i32</code></td><td style="text-align:center"><code>u32</code></td></tr><tr><td style="text-align:center">64-bit</td><td style="text-align:center"><code>i64</code></td><td style="text-align:center"><code>u64</code></td></tr><tr><td style="text-align:center">arch</td><td style="text-align:center"><code>isize</code></td><td style="text-align:center"><code>usize</code></td></tr></tbody></table><blockquote><ol><li>有符号可存储正值和负值，无符号只能存储正值</li><li>有符号的存储范围是 <strong>-(2<sup>n-1</sup>) ~ (2<sup>n-1</sup> - 1)</strong>，n是位数。例如i8可以存储的范围是 -128 ~  127</li><li>无符号的存储范围是 <strong>0 ~ (2<sup>n</sup> - 1)</strong>，例如 u8 可以存储的范围是 0 ~ 255</li><li><strong>isize</strong>和<strong>usize</strong>依赖于运行程序的计算机架构，64位架构上，它们就是64位，32位架构上，它们就是32位</li><li>默认类型是 <code>i32</code></li></ol></blockquote><h4 id="2-浮点型"><a href="#2-浮点型" class="headerlink" title="2. 浮点型"></a>2. 浮点型</h4><p>浮点型分为 <code>f32</code> 和 <code>f64</code>，默认类型是 <code>f64</code></p><h4 id="3-布尔型"><a href="#3-布尔型" class="headerlink" title="3. 布尔型"></a>3. 布尔型</h4><p>布尔型只有两个值 <code>true</code>，<code>false</code>。<code>let is_student: bool = false;</code></p><h4 id="4-字符型"><a href="#4-字符型" class="headerlink" title="4. 字符型"></a>4. 字符型</h4><p>字符型使用单引号，例如 <code>let c1: char = &#39;A&#39;;</code>， <code>let c1: char = &#39;ℤ&#39;;</code>。有一点要注意的是，<strong>Rust 的 char 类型代表了一个 Unicode 标量值（Unicode Scalar Value），这意味着它可以比 ASCII 表示更多内容。在 Rust 中，拼音字母（Accented letters），中文、日文、韩文等字符，emoji（绘文字）以及零长度的空白字符都是有效的 char 值。</strong></p><h4 id="5-数组类型"><a href="#5-数组类型" class="headerlink" title="5. 数组类型"></a>5. 数组类型</h4><p>每个元素的类型必须相同，数组的长度不能动态增长或缩小。如果要修改数组中的某个值，则数组定义时要加 <code>mut</code> 才行<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ,<span class="number">4</span> ,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> b: [<span class="built_in">i32</span>: <span class="number">10</span>] = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>];</span><br><span class="line"><span class="keyword">let</span> num1 = a[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">let</span> num2 = a[<span class="number">1</span>];</span><br></pre></td></tr></table></figure></p><h4 id="6-元祖类型"><a href="#6-元祖类型" class="headerlink" title="6. 元祖类型"></a>6. 元祖类型</h4><p>元祖类型是将多个相同或不同类型的值，组合起来。如果要修改元祖中的某个值，则元祖定义时要加<code>mut</code>才行。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> tup = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">"haha"</span>, <span class="string">'c'</span>, <span class="string">'B'</span>);</span><br><span class="line"><span class="keyword">let</span> tup2: (<span class="built_in">i32</span>, <span class="built_in">char</span>, <span class="built_in">char</span>) = (<span class="number">15</span>, <span class="string">'C'</span>, <span class="string">'D'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这一句称作解构元祖(destructuring), 将tup2中的值分给赋值给x,y,z</span></span><br><span class="line"><span class="keyword">let</span> (x, y z) = tup2;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问元祖中的某个值</span></span><br><span class="line"><span class="keyword">let</span> x = tup2.<span class="number">0</span>; <span class="comment">// 访问第0个值</span></span><br><span class="line"><span class="keyword">let</span> y = tup2.<span class="number">1</span>; <span class="comment">// 访问第1个值</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这里来聊一下Rust的变量声明，以及基本的数据类型。&lt;/p&gt;
&lt;h2 id=&quot;可变性&quot;&gt;&lt;a href=&quot;#可变性&quot; class=&quot;headerlink&quot; title=&quot;可变性&quot;&gt;&lt;/a&gt;可变性&lt;/h2&gt;&lt;p&gt;与其他编程语言很不同的一点是，Rust 的变量默认是不可变的。&lt;
      
    
    </summary>
    
      <category term="Rust 基础学习" scheme="https://solleter.me/categories/Rust-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Rust" scheme="https://solleter.me/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>Rust基础学习-02-创建及运行工程</title>
    <link href="https://solleter.me/2019/09/01/Rust%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0-02-%E5%88%9B%E5%BB%BA%E5%8F%8A%E8%BF%90%E8%A1%8C%E5%B7%A5%E7%A8%8B/"/>
    <id>https://solleter.me/2019/09/01/Rust基础学习-02-创建及运行工程/</id>
    <published>2019-09-01T04:57:35.000Z</published>
    <updated>2019-09-11T13:47:50.123Z</updated>
    
    <content type="html"><![CDATA[<p>这篇博客将介绍使用 <code>cargo</code> 来创建，测试，编译，运行工程。在使用 <code>cargo</code> 之前，我们先来说一下不用 cargo 的情况下，直接用 <code>rustc</code> 编译代码。</p><h2 id="使用-rustc-编译代码"><a href="#使用-rustc-编译代码" class="headerlink" title="使用 rustc 编译代码"></a>使用 <code>rustc</code> 编译代码</h2><p>首先我们新建一个文件 <code>hello.rs</code>，里面写上下面的代码<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"hello rust!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后在终端使用命令 <code>rustc hello.rs</code> 编译代码，之后可以看到在 hello.rs 所在目录生成了一个名为 <code>hello</code> 的可执行文件，运行 <code>hello</code> 这个可执行文件，将输出 <code>hello rust!</code> ，好了，你已经学会了使用 <code>rustc</code> 编译 rust 代码。</p><h2 id="使用-cargo"><a href="#使用-cargo" class="headerlink" title="使用 cargo"></a>使用 <code>cargo</code></h2><p><code>cargo</code> 是 rust 的构建系统和包管理器。使用 cargo 可以很方便的构建代码，下载依赖库，测试代码等。所以大多数情况，推荐使用 cargo 来构建项目。</p><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><ul><li><strong><code>cargo new first-project</code></strong><br>创建一个新项目，这里的项目名使用 first-project， 可以自定义<br><br></li><li><strong><code>cargo build</code></strong><br>构建项目，这个命令需要先 <code>cd first-project</code> 进入到项目目录下，然后再运行。运行后会生成项目的可执行文件。<br><br></li><li><strong><code>cargo run</code></strong><br>运行构建好的项目。也可以不用 <code>cargo build</code>， 直接 <code>cargo run</code>，cargo如果发现项目没有编译，或者有改变，将自动重新去build，然后自动运行。<br><br></li><li><strong><code>cargo build --release</code></strong><br>构建发布版本<br><br></li><li><strong><code>cargo run --release</code></strong><br>运行发布版本<br><br></li><li><strong><code>cargo check</code>，<code>cargo check --release</code></strong><br>这个是用来快速检查代码确保可以编译，但并不产生可执行文件。这个命令比<code>cargo build</code> 快的多。如果项目比较大，编译时间比较长，可以先用这个命令检查一个代码是否能够通过编译。</li></ul><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><ul><li><code>cargo build</code> 时，如果 cargo 发现已经 build 过，但是代码没有改变，将不会再次 build。</li><li>查看 <code>first-project</code> 会发现有几个自动生成的文件<ul><li><code>Cargo.toml</code> 这个是项目的配置文件，项目的一些依赖，也都配置在这里面，这个后面用到时再细说。</li><li><code>Cargo.lock</code> 这个是<code>cargo</code>用来记录项目依赖的实际版本，不要管就OK。</li><li><code>src</code>目录是代码目录，里面的 <code>main.rs</code> 是项目的入口。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这篇博客将介绍使用 &lt;code&gt;cargo&lt;/code&gt; 来创建，测试，编译，运行工程。在使用 &lt;code&gt;cargo&lt;/code&gt; 之前，我们先来说一下不用 cargo 的情况下，直接用 &lt;code&gt;rustc&lt;/code&gt; 编译代码。&lt;/p&gt;
&lt;h2 id=&quot;使用-ru
      
    
    </summary>
    
      <category term="Rust 基础学习" scheme="https://solleter.me/categories/Rust-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Rust" scheme="https://solleter.me/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>Rust基础学习-01-安装Rust</title>
    <link href="https://solleter.me/2019/08/29/Rust%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0-01-%E5%AE%89%E8%A3%85Rust/"/>
    <id>https://solleter.me/2019/08/29/Rust基础学习-01-安装Rust/</id>
    <published>2019-08-29T11:06:52.000Z</published>
    <updated>2019-09-11T13:47:50.122Z</updated>
    
    <content type="html"><![CDATA[<p>关于Rust的介绍，这里不再描述什么，网络上已经有很多信息了，这里，我们直接开始。这个系列的博客，是在学习 <a href="https://kaisery.github.io/trpl-zh-cn/" target="_blank" rel="noopener">Rust程序设计语言 简体中文版本</a> 过程中的一些笔记。有很多地方，也参考了官方的英文版本。</p><blockquote><p>关于是否应该学习Rust，这个没有标准答案，对于我来说，主要是想在编译型系统级语言上有点积累，因为我对C++只是了解，大概能看懂，远没达到熟练码代码的层次，但是我又不想学习C++，所以就选择了Rust。</p></blockquote><h4 id="在安装之前，有几个东西要大概明白"><a href="#在安装之前，有几个东西要大概明白" class="headerlink" title="在安装之前，有几个东西要大概明白"></a>在安装之前，有几个东西要大概明白</h4><ul><li><code>Rustup</code> 是用来安装、更新、管理 Rust 不同平台版本的东西</li><li><code>Rust</code> 版本有 <code>Stable</code>，<code>Nightly</code>，一些新特性一般会在 Nightly 版本里，稳定了后官方可能会加到Stable里，一般情况我们使用Stable版本就可以</li><li><code>toolchain</code> 这里我们简单地理解为某个Rust版本就行</li><li>在 Windows 上，会发现即使 Stable 版本，也会有 <code>gnu</code> 和 <code>msvc</code> 两种版本，目前使用哪种都行，默认在windows上使用的是msvc，这里保持默认就行</li><li><code>cargo</code> 用于组织Rust项目项目，例如创建项目，构建项目，测试项目等。</li></ul><h2 id="下载和安装-Rustup"><a href="#下载和安装-Rustup" class="headerlink" title="下载和安装 Rustup"></a>下载和安装 Rustup</h2><p>访问 <a href="https://www.rust-lang.org/zh-CN/tools/install" target="_blank" rel="noopener"><code>https://www.rust-lang.org/zh-CN/tools/install</code></a>，如果是在Windows系统下，那就下载 <code>RUSTUP-INIT.EXE</code>，如果是OSX或者Linux等，就使用它的脚本下载 <code>curl https://sh.rustup.rs -sSf | sh</code></p><h2 id="安装-Rust"><a href="#安装-Rust" class="headerlink" title="安装 Rust"></a>安装 Rust</h2><p>下载好 <code>rustup</code> 后就运行，osx或linux下应该会自动运行，运行后会出现下面的界面<br><img src="https://i.loli.net/2019/08/30/W2LFYi1ZNoEHnal.png" alt="1.png"><br>这里保持默认就好，输入 <code>1</code> 然后按回车，进行安装。这里可以看到默认安装的是 <code>stable msvc</code> 版本的 <code>rust</code>。这里会自动下载，安装，然后设置。</p><p><img src="https://i.loli.net/2019/08/30/WZ8KIkOVRn7QBMq.png" alt="2.png"><br>到这里，看到这个界面，就表示已经下载和安装好，可以使用了。</p><h2 id="查看及修改配置"><a href="#查看及修改配置" class="headerlink" title="查看及修改配置"></a>查看及修改配置</h2><ol><li><code>rustc --version</code> 查看 rustc 版本</li><li><code>cargo --version</code> 查看 cargo 版本</li><li><code>rustup toolchain list</code> 列出当前已经安装的 rust 版本, (default) 为当前使用的版本</li><li><code>rustup default stable-x86_64-pc-windows-msvc</code><br> 设置使用 stable msvc 版本的 rust (可以简写为 stable-msvc)</li><li><code>rustup default stable-x86_64-pc-windows-gnu</code><br> 设置使用 stable gnu 版本的 rust (可以简写为 stable-gnu)</li></ol><h4 id="下一篇开始使用-cargo-创建工程，开始写代码"><a href="#下一篇开始使用-cargo-创建工程，开始写代码" class="headerlink" title="下一篇开始使用 cargo 创建工程，开始写代码"></a>下一篇开始使用 <code>cargo</code> 创建工程，开始写代码</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;关于Rust的介绍，这里不再描述什么，网络上已经有很多信息了，这里，我们直接开始。这个系列的博客，是在学习 &lt;a href=&quot;https://kaisery.github.io/trpl-zh-cn/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Rust
      
    
    </summary>
    
      <category term="Rust 基础学习" scheme="https://solleter.me/categories/Rust-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Rust" scheme="https://solleter.me/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>聊聊游戏开发中的逻辑层框架模块</title>
    <link href="https://solleter.me/2019/08/26/%E8%81%8A%E8%81%8A%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E9%80%BB%E8%BE%91%E5%B1%82%E6%A1%86%E6%9E%B6%E6%A8%A1%E5%9D%97/"/>
    <id>https://solleter.me/2019/08/26/聊聊游戏开发中的逻辑层框架模块/</id>
    <published>2019-08-26T15:28:12.000Z</published>
    <updated>2019-09-01T01:21:07.225Z</updated>
    
    <content type="html"><![CDATA[<p>不管是端游还是手游，在游戏引擎提供的基本支持之上，一个项目，通常还是需要自己的逻辑层框架。今天，我们就聊一聊一个游戏项目基本的逻辑层框架组成部。这里以Unity3D引擎为例，但不限于Unity3D引擎。</p><h4 id="资源管理"><a href="#资源管理" class="headerlink" title="资源管理"></a>资源管理</h4><blockquote><p>一个项目开始，最好就规划好资源目录。随着项目的开发，资源会越来越多，越往后，越难整理，而且需要耗费大量时间和精力，所以建议随着项目的开发，就不断地做好资源规划和整理的工作。</p></blockquote><h4 id="编辑器阶段"><a href="#编辑器阶段" class="headerlink" title="编辑器阶段"></a>编辑器阶段</h4><blockquote><ol><li><strong>资源打包模块</strong><br> 对于Unity3D来说，主要是打包 AssetBundle<br> <br></li><li><strong>配置表导出模块</strong><br> 很多游戏的大量配置，使用excel的形式，所以必然需要一个工具能够将excel表结构，转为代码，并且把表数据，导出到游戏运行时能够解析的格式，例如二进制。还可以自动生成运行时加载解析代码。<br> <br></li><li><strong>协议导出模块</strong><br> 很多游戏使用了google的 FlatBuffers 或者 Protocol Buffers，这里需要一个工具自动化地将协议文件导出成客户端和服务器使用的代码文件。</li></ol></blockquote><h3 id="运行时阶段"><a href="#运行时阶段" class="headerlink" title="运行时阶段"></a>运行时阶段</h3><blockquote><ol><li><strong>更新模块</strong><br> 这个模块主要是根据项目自定义的版本信息，从网络上自动下载需要更新的资源文件，以及代码文件，这里通常使用lua，然后解压到资源目录。这里面涉及到两个重要的东西，一个是版本和资源文件的定义，一个是HTTP请求模块。对于Unity3D，通常使用 UnityWebRequest<br><br></li><li><strong>网络通信模块</strong><br> TCP 或者 UDP，用于客户端和服务器的逻辑通信。收发包数据，根据协议号处理协议，具体处理函数为业务逻辑。<br> <br></li><li><strong>UI管理器</strong><br> 如果是MVC结构，定义好UI面板的基类，各UI类继承基类。UI分层，普通UI面板层，弹出式面板层，Loading层，特效层，等等，具体根据项目需求灵活定义。<br> <br></li><li><strong>事件系统</strong><br> 用于整个工程的业务逻辑之间通信。不过事件这种东西，有一个不好处就是有时候调试起来不是很直接，有时候难以确定是从哪里发来的事件，有弊有利。<br> <br></li><li><strong>代码热更新模块</strong><br> 现在比较常用的解决方案是 lua，虽然写起来比较蛋疼，但是很多项目都这样用，也许是因为没有更好的解决方案，也许是因为技术决策者的经验之谈，这里就呵呵了。<br> <br></li><li><strong>原生交互模块</strong><br> 对于手游，通常分为Android和iOS版本，不同的版本有一些地方需要和原生系统交互，例如将游戏截图保存到相册，这样就需要调用原生系统的API。一些SDK的接入相关的东西，也可以归于这个模块。<br> <br></li><li><strong>一些小的工具类集合</strong><br> <br></li><li><strong>配置表加载解析模块</strong><br> 就是将编辑器阶段打包好的配置表数据，在这里读出来，存起来，用于游戏业务逻辑使用<br> <br></li><li><strong>数据读写模块</strong><br> 有时候需要将一些数据写到本地，对于不同的平台，Android，iOS，PC，存储的路径不同，这个模块会将这些都封装好，上层业务只管用就行，不需要关心路径问题。<br> <br></li><li><strong>音频模块</strong><br>游戏内音频播放及管理，例如同一音源，最多有多少个的控制，等等<br><br></li><li><strong>日志模块</strong><br>日志的打印，各平台写入文件，设备上在屏幕上显示下隐藏，等等</li></ol></blockquote><h4 id="暂时先写这么多，后面不断补充"><a href="#暂时先写这么多，后面不断补充" class="headerlink" title="暂时先写这么多，后面不断补充 :)"></a>暂时先写这么多，后面不断补充 :)</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;不管是端游还是手游，在游戏引擎提供的基本支持之上，一个项目，通常还是需要自己的逻辑层框架。今天，我们就聊一聊一个游戏项目基本的逻辑层框架组成部。这里以Unity3D引擎为例，但不限于Unity3D引擎。&lt;/p&gt;
&lt;h4 id=&quot;资源管理&quot;&gt;&lt;a href=&quot;#资源管理&quot; c
      
    
    </summary>
    
    
      <category term="游戏开发" scheme="https://solleter.me/tags/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    
      <category term="Unity3D" scheme="https://solleter.me/tags/Unity3D/"/>
    
  </entry>
  
  <entry>
    <title>在游戏公司工作-02-人员架构</title>
    <link href="https://solleter.me/2019/08/18/%E5%9C%A8%E6%B8%B8%E6%88%8F%E5%85%AC%E5%8F%B8%E5%B7%A5%E4%BD%9C-02-%E4%BA%BA%E5%91%98%E6%9E%B6%E6%9E%84/"/>
    <id>https://solleter.me/2019/08/18/在游戏公司工作-02-人员架构/</id>
    <published>2019-08-17T16:17:52.000Z</published>
    <updated>2019-09-01T01:21:07.225Z</updated>
    
    <content type="html"><![CDATA[<p>这一篇博客来聊一下一个游戏公司的人员架构，以及不同职位大概做的事情。</p><blockquote><p>这里要说明的一点是，每一个游戏公司的人员架构可能都不一样，并没有严格的标准，以及一些事情应该哪个职位的人去做，也没有什么精确的标准，每一个公司都是根据实际情况灵活调整。有的公司可能有更多的职位分类，有的公司，可能也没有分的这么细，这里不必过于纠结。</p></blockquote><p><strong>先来看一张某游戏公司的人员架构图</strong></p><p><img src="https://i.loli.net/2019/08/18/oK1gYPnZN9jAzSf.png" alt="1.png"></p><p>接下来，我们将按照上面的这张图有架构，来逐一介绍每一个职位，以及做的事情，这里只做简要说明。</p><h2 id="总裁办"><a href="#总裁办" class="headerlink" title="总裁办"></a>总裁办</h2><h4 id="1-CEO"><a href="#1-CEO" class="headerlink" title="1. CEO"></a>1. CEO</h4><blockquote><p>这个貌似没什么可说的</p></blockquote><h4 id="2-PM"><a href="#2-PM" class="headerlink" title="2. PM"></a>2. PM</h4><blockquote><p>产品经理，负责整个产品的研发进度跟进，人员工作内容上的协调，任务分配等，这里的任务分配不是PM自己决定哪个任务分给谁做，而是与开发，美术交流，了解谁做哪一个模块，然后将任务和时间排到任务系统里。主要任务是时间分配与项目跟进。确保整个产品各个版本在计划的时间节点完成。</p></blockquote><h4 id="3-人事行政"><a href="#3-人事行政" class="headerlink" title="3. 人事行政"></a>3. 人事行政</h4><blockquote><p>人事主要负责员工的入职，离职。行政负责</p></blockquote><h4 id="4-财务"><a href="#4-财务" class="headerlink" title="4. 财务"></a>4. 财务</h4><blockquote><p>给大家发工资</p></blockquote><h2 id="策划部"><a href="#策划部" class="headerlink" title="策划部"></a>策划部</h2><h4 id="1-策划总监"><a href="#1-策划总监" class="headerlink" title="1. 策划总监"></a>1. 策划总监</h4><blockquote><p>每一个设计最终都会过一遍策划总监，貌似是最终拍板的那个人</p></blockquote><h4 id="2-系统策划"><a href="#2-系统策划" class="headerlink" title="2. 系统策划"></a>2. 系统策划</h4><blockquote><p>游戏中的各个系统，例如地图，背包，邮件，等等</p></blockquote><h4 id="3-关卡策划"><a href="#3-关卡策划" class="headerlink" title="3. 关卡策划"></a>3. 关卡策划</h4><blockquote><p>具体的玩法</p></blockquote><h4 id="4-剧情策划"><a href="#4-剧情策划" class="headerlink" title="4. 剧情策划"></a>4. 剧情策划</h4><blockquote><p>游戏中的剧情设计，文案等</p></blockquote><h4 id="5-数值策划"><a href="#5-数值策划" class="headerlink" title="5. 数值策划"></a>5. 数值策划</h4><blockquote><p>整个游戏中的数值系统</p></blockquote><h2 id="美术部"><a href="#美术部" class="headerlink" title="美术部"></a>美术部</h2><h4 id="1-艺术创意总监"><a href="#1-艺术创意总监" class="headerlink" title="1. 艺术创意总监"></a>1. 艺术创意总监</h4><blockquote><p>游戏的美术风格把控</p></blockquote><h4 id="2-主美"><a href="#2-主美" class="headerlink" title="2. 主美"></a>2. 主美</h4><blockquote><p>游戏部分各部分美术的负责人，以及协调整个美术部的工作</p></blockquote><h4 id="3-UE-UI"><a href="#3-UE-UI" class="headerlink" title="3. UE/UI"></a>3. UE/UI</h4><blockquote><p>UI及交互设计</p></blockquote><h4 id="4-原画"><a href="#4-原画" class="headerlink" title="4. 原画"></a>4. 原画</h4><blockquote><p>设计及画出游戏中的场景，角色等</p></blockquote><h4 id="5-3D"><a href="#5-3D" class="headerlink" title="5. 3D"></a>5. 3D</h4><blockquote><p>将原画的设计，进行3D建模，最终放到游戏中使用</p></blockquote><h4 id="6-动作"><a href="#6-动作" class="headerlink" title="6. 动作"></a>6. 动作</h4><blockquote><p>游戏中所有的动画制作，例如角色的，场景的等等</p></blockquote><h4 id="7-特效"><a href="#7-特效" class="headerlink" title="7. 特效"></a>7. 特效</h4><blockquote><p>游戏中的特效设计，包括场景中，及UI上的特效，UI上很多动画效果，也都是特效这个人做</p></blockquote><h2 id="程序部"><a href="#程序部" class="headerlink" title="程序部"></a>程序部</h2><h4 id="1-CTO"><a href="#1-CTO" class="headerlink" title="1. CTO"></a>1. CTO</h4><blockquote><p>整个公司的首席技术官，有的公司的CTO是不写代码的，主要是把控产品的技术方向，但是我们公司的CTO，是程序这边最辛苦的，每天都在写代码，晚上走的最晚，早上基本上来的比较早。有时候写客户端渲染方面的代码，有时候写服务器的模块。</p></blockquote><h4 id="2-主程-包括服务器主程和客户端主程"><a href="#2-主程-包括服务器主程和客户端主程" class="headerlink" title="2. 主程(包括服务器主程和客户端主程)"></a>2. 主程(包括服务器主程和客户端主程)</h4><blockquote><p>把控工程的框架层面的东西，也会做一些业务模块。</p></blockquote><h4 id="3-程序-包括服务器程序和客户端程序"><a href="#3-程序-包括服务器程序和客户端程序" class="headerlink" title="3. 程序(包括服务器程序和客户端程序)"></a>3. 程序(包括服务器程序和客户端程序)</h4><blockquote><p>主要是实现各个业务模块</p></blockquote><h4 id="4-测试"><a href="#4-测试" class="headerlink" title="4. 测试"></a>4. 测试</h4><blockquote><p>负责产品测试，提Bug，验证Bug</p></blockquote><h2 id="音频部"><a href="#音频部" class="headerlink" title="音频部"></a>音频部</h2><blockquote><p>游戏中的所有音频制作</p></blockquote><h2 id="商务部"><a href="#商务部" class="headerlink" title="商务部"></a>商务部</h2><blockquote><p>项目推广方面的事情吧，细节不是很了解。</p></blockquote><p><strong>再次说明一下，每一个游戏公司的情况都是不一样的，所以大概了解一下就OK，不要太认真。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这一篇博客来聊一下一个游戏公司的人员架构，以及不同职位大概做的事情。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这里要说明的一点是，每一个游戏公司的人员架构可能都不一样，并没有严格的标准，以及一些事情应该哪个职位的人去做，也没有什么精确的标准，每一个公司都是根据实际情况灵活调
      
    
    </summary>
    
      <category term="在游戏公司工作" scheme="https://solleter.me/categories/%E5%9C%A8%E6%B8%B8%E6%88%8F%E5%85%AC%E5%8F%B8%E5%B7%A5%E4%BD%9C/"/>
    
    
      <category term="工作" scheme="https://solleter.me/tags/%E5%B7%A5%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>在游戏公司工作-01-体验</title>
    <link href="https://solleter.me/2019/08/16/%E5%9C%A8%E6%B8%B8%E6%88%8F%E5%85%AC%E5%8F%B8%E5%B7%A5%E4%BD%9C-01-%E4%BD%93%E9%AA%8C/"/>
    <id>https://solleter.me/2019/08/16/在游戏公司工作-01-体验/</id>
    <published>2019-08-16T15:58:27.000Z</published>
    <updated>2019-09-01T01:21:07.223Z</updated>
    
    <content type="html"><![CDATA[<p>我在一家不是很大也不是很小的游戏公司，做游戏开发工作，具体职位是客户端开发，这篇博客不对职位具体的内容做详解，后期会有一篇博客专门描述。</p><p>这里聊一下工作时间。每天9点~10点上班，弹性制，下班时间为18点~19点，也就是说，9点到公司，晚上18点就可以下班走，10点到公司，那就要19点才能下班打卡。但是一般在公司待的时间，都会大于9个小时。工作时间是按8个小时算的，中午12点~13点为休息吃饭时间，所以加起来就是9个小时。</p><p>有一些公司严格按照打卡时间来考勤，我们公司并没有很严格，即使10点以后到，晚个十几分钟，也没关系，下班时间自己顺延就OK，很人性化。</p><p>再说一下加班情况。首先有一条原则是这样的，所有的一切，都是为了把当前的游戏，或者说每个人负责的工作，保质保量地完成，只要这一条达到了，其他的一切，都没有硬性规定。就我们公司而言，不忙的时候，基本上不会从规定上要求大家加班，只有临近版本节点状态，才会有一定的要求。例如我们现阶段临近出下一个版本，所以最近两个月大家周六是上班的。有特别事情也可以说一下，就不用去公司了，只要自己负责的事情在规定的时间内做好就OK。过去这段时间，就会恢复双休。</p><p>平时没有要求加班到几点几点，也都是各自按自己的节奏来，有的人感觉今天很疲惫，那可能就会早点走。有的人工作量有点多，可能就会多忙一会，有的人也会在公司里看点工作之外的东西，或者玩会游戏，并不是待在公司里，就一定是在加班或者工作。</p><p>我很喜欢我们公司的一点就是，没有人会盯着你是不是在工作，是不是在磨洋工。也可能这批员工都很不错，每个人都有明确的任务，大家对自己的工作都很上心，所以每个人都尽可能地在规划时间内完成。</p><p><strong>整体来说，工作氛围和方式，是很舒心的。</strong></p><p>再来聊一下工作模式。PM会先把下一个版本要开发的内容都规划好，然后具体到哪一个人做，然后会和每一个人对一下时间，每一个功能模块，需要要多长时间。一般是按周来算的。有一些小的功能，不需要很长的时间，也会并行开发。</p><p>很多人工作的时候是戴着耳机听着音乐的，那些不允许戴耳机的公司，可能不是正宗的IT公司。有些人可能好奇，戴着耳机工作不会分心吗？其实，并不会，反而会让人更加专注，至少我是这样。音乐会屏蔽掉周围的一些噪音，当专注点进入工作内容后，音乐放的是什么，已经不那么重要，那个时间大脑已经没有在关注音乐。</p><p>还有一点很重要，公司的整个人员架构是扁平化的，没有任何政治斗争，大家都是干活的，也没有传统企业那些各种各样的头衔。和同事，和CTO，CEO聊东西，没有任何区别，他们没有任何上级的架子。不像某些传统企业，见到哪怕比自己稍大一点职位的人，很多人都会恭恭敬敬的奉献虚伪。这里找不到合适的描述，大家自己体会。</p><p>这篇文章先写到这里，想到更多的再补充。如果有幸被某些读者看到，有任何想问的，欢迎在下面留言。</p><p>晚安，北京。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我在一家不是很大也不是很小的游戏公司，做游戏开发工作，具体职位是客户端开发，这篇博客不对职位具体的内容做详解，后期会有一篇博客专门描述。&lt;/p&gt;
&lt;p&gt;这里聊一下工作时间。每天9点~10点上班，弹性制，下班时间为18点~19点，也就是说，9点到公司，晚上18点就可以下班走，
      
    
    </summary>
    
      <category term="在游戏公司工作" scheme="https://solleter.me/categories/%E5%9C%A8%E6%B8%B8%E6%88%8F%E5%85%AC%E5%8F%B8%E5%B7%A5%E4%BD%9C/"/>
    
    
      <category term="工作" scheme="https://solleter.me/tags/%E5%B7%A5%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>图解经济学-07-市场和福利</title>
    <link href="https://solleter.me/2019/08/04/%E5%9B%BE%E8%A7%A3%E7%BB%8F%E6%B5%8E%E5%AD%A6-07-%E5%B8%82%E5%9C%BA%E5%92%8C%E7%A6%8F%E5%88%A9/"/>
    <id>https://solleter.me/2019/08/04/图解经济学-07-市场和福利/</id>
    <published>2019-08-04T15:26:57.000Z</published>
    <updated>2019-09-01T01:21:07.223Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-消费者剩余"><a href="#1-消费者剩余" class="headerlink" title="1. 消费者剩余"></a><strong>1. 消费者剩余</strong></h2><p>消费者剩余是买者愿意为一种物品支付的量减去其为此实际支付的量。例如一件物品，你原本打算花100块买这件物品，但是最后你只花了90块，那10块钱就是消费者剩余。</p><p>买者总希望能以最低的价格买到他们想要的物品。因而价格的降低使得买者得到的经济福利增加了。</p><h2 id="2-生产者剩余"><a href="#2-生产者剩余" class="headerlink" title="2. 生产者剩余"></a><strong>2. 生产者剩余</strong></h2><p>生产者剩余是卖者卖出的物品得到的收益减去其成本。只有在竞争市场中才存在生产者剩余。</p><p>卖者总希望把物品卖个好价钱，以得到更多的生产者剩余</p><h2 id="3-总剩余"><a href="#3-总剩余" class="headerlink" title="3. 总剩余"></a><strong>3. 总剩余</strong></h2><p>衡量社会经济福利的一个指标是消费者剩余加上生产者剩余，它们的总和就是总剩余。</p><p>如果说，市场是买卖双方参与制作和分割的一块蛋糕，那么效率指的是如何把这块蛋糕做大做厚，而公平则是指如何公正地切割蛋糕。</p><h2 id="4-关于完全竞争市场"><a href="#4-关于完全竞争市场" class="headerlink" title="4. 关于完全竞争市场"></a><strong>4. 关于完全竞争市场</strong></h2><p>生产者和消费者共同决定着市场的价格。只有当消费者对物品的评价高于价格时，消费者才愿意掏钱购买物品；否则，就不买。只有在成本低于市场价格时，生产者才会销售物品。</p><p>当买者的评价高于卖者的成本时，整个社会增加产量能使总剩余增加；当买者的评价低于卖者的成本时，减少产量能增加社会总剩余。只有在供给和需求处于均衡位置时，买者的评价和卖者的成本刚好相等，此时，整个社会的总剩余也是最大的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-消费者剩余&quot;&gt;&lt;a href=&quot;#1-消费者剩余&quot; class=&quot;headerlink&quot; title=&quot;1. 消费者剩余&quot;&gt;&lt;/a&gt;&lt;strong&gt;1. 消费者剩余&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;消费者剩余是买者愿意为一种物品支付的量减去其为此实际支付的量。
      
    
    </summary>
    
      <category term="图解经济学" scheme="https://solleter.me/categories/%E5%9B%BE%E8%A7%A3%E7%BB%8F%E6%B5%8E%E5%AD%A6/"/>
    
    
      <category term="经济学" scheme="https://solleter.me/tags/%E7%BB%8F%E6%B5%8E%E5%AD%A6/"/>
    
  </entry>
  
</feed>
